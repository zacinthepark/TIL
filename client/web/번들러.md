## Bundler

---

많은 Javascript 프로젝트에서 모듈화를 위해 다양한 번들러를 사용하고 있다. 프로젝트가 고도화될수록 번들러 설정을 구성해야하는 상황이 발생할 수 있다. 프론트엔드 개발자로서 모듈과 번들러를 이해하고 빌드 최적화까지 고려할 수 있어야 더 똑똑하게 개발할 수 있을 것이다.

![bundling](https://github.com/zacinthepark/TIL/assets/86648892/9fddaf00-e249-42de-975d-1b84996e6765)

## 자바스크립트의 모듈화

---

- 개발하는 애플리케이션의 크기가 커지면 파일을 여러 개로 분리하게 되며, 이 때 분리된 파일 각각을 ‘모듈(module)’이라고 부른다

- ES5, ES6의 `[ export (name, default) | import ]` , commonJS의 `[ module.exports | require ]` 문법을 사용하여 쉽게 모듈을 만들 수 있다

- 플러그인 파일이나 잘게 쪼개진 자바스크립트 코드 조각을 재사용하기 위해 각각의 파일을 등록하고, 등록된 파일을 자바스크립트에서 불러와서 사용할 수 있게 된다

- 왜 모듈화가 필요한가?

    - 기능의 분리가 가능하고 인터페이스가 단순해진다
        - 하나의 파일에 많은 기능들을 작성하게 되면 코드 의미 파악이 어려워지고 관리가 어려워진다. 그렇기에 하나의 파일로 관리하는 것이 아니라 각 기능 별로 파일을 분리해서 관리하는 것이 필요하다

    - 각 모듈은 자신만의 스코프를 보장해준다
        - 한 파일 내에 모든 코드를 관리하면 변수나 함수가 중복되거나 다른 기능의 코드끼리 영향을 줄 수 있다. 따라서 기능별로 코드를 분리하여 여러 파일로 나누면 서로 분리된 파일끼리는 영향을 주고받지 않는다

    - 모듈 재사용으로 개발과 유지보수가 용이해진다
        - 공통된 기능이나 UI를 사용하는 부분이 있다면 우리는 이를 공통 컴포넌트로 분리하여 어디서든 사용할 수 있다

    - 디버깅, 테스트 시 용이성을 제공해준다
        - 특히 단위 테스트에 용이하다. 단위 테스트란 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다. 해당 부분만 독립적으로 테스트하기 때문에 어떤 코드를 리팩토링하더라도 빠르게 문제 여부를 파악할 수 있다

사실 자바스크립트는 원래 웹 페이지 내 보조 작업을 처리하기 위한 언어였기에 다른 언어와 달리 모듈 시스템이 없었다. 자바스크립트는 주로 웹 서버에서 실행되었고 브라우저는 서버로부터 전달받은 html, css를 단순히 렌더링만 하는 수준이었다. 그런데 자바스크립트로 더 복잡한 작업들을 처리하고자 하는 니즈가 생기게 됨에 따라 자바스크립트는 빠르게 진화하기 시작하였고 모듈 시스템도 등장하게 되었다.

![jshistory](https://github.com/zacinthepark/TIL/assets/86648892/5a1587a2-f740-46cb-8b77-5415f651bc8b)

## 번들러란?

---

**번들러는 의존성이 있는 모듈 코드를 하나 혹은 여러 개의 파일로 만들어주는 도구이다**

React, Angular, Vue와 같은 JS 프레임워크가 등장하면서 웹 사이트를 구축하기 위한 파일들이 점점 많아졌다. 이렇게 많은 모듈들을 하나로 묶는 과정은 어렵다.

변수 또는 함수명이 중복되는 경우나 모듈 간의 종속성 때문에 배포하기 전에 많은 문제가 발생할 수 있고 많은 시간을 소모하게 된다.

그리고 모든 브라우저에서 모듈 시스템을 지원하는 것은 아니다. 크롬 브라우저 버젼 61부터는 모듈 시스템을 지원하고 있으나, 지원하지 않는 브라우저도 있다. 브라우저와 무관하게 모듈을 사용 할 수는 없을까?

또한 한 페이지에서 사용하는 JS 파일들이 엄청나게 많다고 했을 때, 웹 페이지가 로드될 때 JS 파일 모두를 네트워크를 통해 받아와야 한다. 이 때 한 번에 요청하는 수가 많아져 네트워크 병목 현상이 발생할 수 있다. 네트워크 속도가 빠르다고 해서 웹 페이지가 완벽하게 로드되는 시간까지 빠른건 아니다. 웹 페이지를 구성하는 js, css , html , 이미지 파일들이 많을수록 웹 서버에 요청하고 응답을 받는 시간이 길어지게 된다.

모듈 번들러는 위의 문제들을 해결하고 애플리케이션을 최적화해준다.

### 번들러의 기능

✅ 모듈 코드를 하나 혹은 여러 개의 파일로 묶어주는 도구

모듈 번들러는 모듈의 의존 관계를 분석하여 브라우저가 인식할 수 있는 자바스크립트 코드로 변환한다.

다음과 같은 효과를 기대할 수 있다:

- 모듈 단위로 개발하여 유지 보수성을 높일 수 있다
    - 번들러를 사용하지 않을 때는 각각의 JS 파일을 사용하기 위해 파일의 종속성을 고려하여 많은 스크립트 태그를 추가해야 했는데, 번들러는 파일끼리의 종속성을 알아서 확인하여 묶어준다

- 한 번에 많은 요청을 하지 않아도 된다
    - 모듈 번들러는 JS 모듈을 브라우저에서 실행할 수 있는 단일 JS 파일로 번들링해준다. 따라서 한 번의 네트워크 요청으로 우리는 웹 페이지를 로드할 수 있게 된다

✅ 최적화

번들러는 성능 향상을 위해 추가 기능을 제공한다.

- Tree Shaking
    - 필요 없는 코드를 제거하고 번들 파일의 크기, 번들링 시간을 줄여준다

- HMR (Hot Module Replacement)
    - 코드가 변경되면 감지하고 브라우저에 최신 코드를 반영하여 자동으로 모듈을 교체한다. 개발자는 새로고침을 하지 않아도 반영된 것을 빠르게 확인할 수 있으며 변경 사항만 업데이트 하기 때문에 개발 속도가 빨라진다

- Code Splitting
    - JS를 청크로 분할하고, 청크가 필요한 경로에만 제공하여 성능을 향상시킨다
    - 모듈 번들러가 의존성 있는 모듈끼리 번들링해서 클라이언트에게 보내 Http Request 통신 횟수를 최소화하여 유저의 로딩 시간을 줄였다. 그런데 이렇게 되면 하나의 번들 파일의 크기가 너무 커지게 된다. 큰 번들을 브라우저에서 파싱하고 컴파일 해야하니 로딩 시간이 더 길어진다
    - 그래서 이러한 문제를 인지하여 코드 스플리팅이라는 개념이 생겼다. 하나의 큰 번들을 여러 개의 번들로 쪼개고 필요한 경로에만 제공하여 최적화를 시킨다

- Transformations
    - 트랜스파일러를 사용하여 ES6 버전 이상의 스크립트를 사용 가능하게 해준다
    - Babel (트랜스파일러)
        - ES6나 JSX등의 최신 고급 문법은 구형 브라우저에서 이해하지 못하는 호환성 문제가 존재한다. 트랜스파일러는 최신 문법을 구형 문법으로 변환해준다. 가장 유명한 것이 Babel이다
        - 실무 환경에서는 바벨을 직접 사용하는 것보다 웹팩으로 통합해서 사용하는 경우가 많다. 웹팩은 babel-loader, css-loader와 같은 로더를 사용한다. 트랜스파일러는 원본 코드를 구형 버전의 JS로 변환해주어 번들러에 전달해준다

### 번들러의 기능 요약

쉽게 말해 지정한 메인 파일에서 시작하여 자바스크립트의 require과 import(ES6)문을 참고하여 프로젝트의 모든 의존성을 조사하고, 로더를 이용해 처리한 후, 번들로 묶은 자바스크립트 파일을 생성하는 것이다.

모듈 번들러의 핵심 작업은 여러 JS 파일을 하나로 결합하여 단일 파일을 만드는 것이다. 따라서 브라우저는 하나의 단일 파일을 로드하는 것 만으로도 애플리케이션이 동작한다. JS뿐만 아니라 CSS, 이미지, 글꼴 등 여러 리소스에 대해서도 번들링할 수 있다. 지금은 번들링 뿐만 아니라 빌드 과정에서의 최적화 등도 지원해주고 있다.

## 번들러 프로세스

---

번들러는 일반적으로 entry file에서 시작하여 해당 파일에 필요한 모든 항목들을 묶는다.

![bundling1](https://github.com/zacinthepark/TIL/assets/86648892/1ae5dfdc-e30d-4d0a-abdb-93315fe53ee3)

✅ 이러한 번들러의 작업은 두 단계로 나뉜다.

1. 의존성 그래프 생성 (Mapping a Dependency Graph)
2. 번들링 (Bundling)

### 의존성 그래프 생성 (Mapping a Dependency Graph)

의존성 해결의 목표는 entry point에서 시작하여(예를 들어, app.js) 모든 코드의 종속성(작동에 필요한 다른 코드 조각)을 해결하고 그래프로 구성하는 것이다.

의존성 그래프 생성을 위해서는 파일의 이름과 식별자, 파일의 경로, 파일의 코드, 파일의 의존성 정보가 필요하다. 그래프는 각 파일의 종속성을 재귀적으로 파악하여 구축된다. JS에서 이러한 데이터를 가장 쉽게 나타낼 수 있는 방법은 객체이다.

![bundling2](https://github.com/zacinthepark/TIL/assets/86648892/52170f4f-4b36-4baa-ab7e-63729cd76a55)

이 정보를 바탕으로 엔트리 파일 중심의 관계성 맵을 그리게 된다. 각 파일에 고유한 ID를 부여하면서 종속성을 탐색한다. 이 때 생성되는 것이 module map이다.

`require('./utils')`처럼 상대 경로로 import를 할 때, 모든 것이 패키징되어 있다면 번들러는 `./utils` 파일이 무엇인지 어떻게 알 수 있을까? 해답은 module map이다. 각 모듈에 대해 고유한 ID값을 가지고 있기 때문에 런타임때 올바른 모듈을 고를 수 있게 된다.

![bundling3](https://github.com/zacinthepark/TIL/assets/86648892/2e486775-2584-4374-9793-3dbcc791f0a7)

마지막으로 모든 의존성을 추출하고, 모든 파일간의 관계를 나타내는 의존성 그래프를 생성한다. 의존성 그래프를 생성하는 과정이 필요한 이유는 아래와 같다.

1. 모듈이 의존성 순서를 구성할 수 있게 해주고, 브라우저가 요청했을 때 관련된 함수를 검색할 때 필수적이기 때문이다.

2. 이름이 중복되어서 충돌나는 것을 막아준다. 번들러가 모든 파일의 의존성에 대한 소스맵을 가지고 있기 때문이다.

3. 사용하지 않는 불필요한 파일을 제거 할 수 있다.

### 번들링 (Bundling)

![bundling4](https://github.com/zacinthepark/TIL/assets/86648892/82d27902-0e2f-4a83-bc7d-739fd70ccad4)

아웃풋을 만드는 단계를 Packing이라고 부른다. 이 과정에서는 의존성 그래프를 활용하여 여러 코드 파일들을 통합한다. 필요한 함수와 `module.exports` 객체를 주입하고, 브라우저에게 줄 수 있는 static한 결과물을 만든다. 즉, 번들링 과정을 통해 모듈을 하나의 실행 가능한 에셋으로 만들게 된다.

## Reference

---

- [번들러에 대한 이해](https://ui.toast.com/fe-guide/ko_BUNDLER)
- [웹팩과 바벨에 대한 이해](https://berkbach.com/%EC%9B%B9%ED%8C%A9-webpack-%EA%B3%BC-%EB%B0%94%EB%B2%A8-babel-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-react-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-fb87d0027766)
