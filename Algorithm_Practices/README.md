# APS

[APS 환경설정 (Pycharm)](#aps-환경설정-pycharm)<br>
[APS 문제풀이 Guidelines](#aps-문제풀이-guidelines)<br>
[APS 유형 Reminder](#aps-유형-reminder)<br>
[입력연습](#입력연습)<br>
[View (List 1)](#view-list1)<br>
[Gravity (List 1)](#gravity-list-1)<br>
[Baby-Gin Game (List 1)](#baby-gin-game-list-1)<br>
[min max (List 1)](#min-max-list-1)<br>
[구간합 (List 1)](#구간합-list-1)<br>
[숫자카드 (List 1)](#숫자-카드-list-1)<br>
[전기버스 (List 1)](#전기버스-list-1)<br>
[Flatten (List 1)](#flatten-list-1)<br>
[정렬연습 (List 1)](#정렬-연습-list-1)<br>
[델타검색 (List 2)](#델타검색-list-2)<br>
[부분집합 합 (비트연산) (List 2)](#부분집합-합-비트연산-list-2)<br>
[달팽이 숫자 (List 2)](#달팽이-숫자-list-2)<br>
[Sum 행열대각선합 (List 2)](#sum-행열대각선합-list-2)<br>
[색칠하기 (List 2)](#색칠하기-list-2)<br>
[원소의 합이 K인 부분집합 개수 (비트연산) (List 2)](#원소의-합이-k인-부분집합-개수-비트연산-list-2)<br>
[코딩반 이진탐색 (List 2)](#코딩반-이진탐색-list-2)<br>
[특별한 정렬 (List 2)](#특별한-정렬-list-2)<br>
[Ladder 1 (List 2)](#ladder-1-list-2)<br>
[이진탐색 연습 (List 2)](#이진탐색-연습-list-2)<br>
[문자열 검색 (String)](#문자열-검색-string)<br>
[GNS (String)](#gns-string)<br>
[간단한 소인수분해 (IM)](#간단한-소인수분해-im)<br>
[현주의 상자 바꾸기 (IM)](#현주의-상자-바꾸기-im)<br>
[삼성시의 버스 노선 (IM)](#삼성시의-버스-노선-im)<br>
[파리 퇴치 (IM)](#파리-퇴치-im)<br>
[어디에 단어가 들어갈 수 있을까 (IM)](#어디에-단어가-들어갈-수-있을까-im)<br>
[스도쿠 검증 (IM)](#스도쿠-검증-im)<br>
[자기 방으로 돌아가기 (IM)](#자기-방으로-돌아가기-im)<br>
[파리 퇴치 3 (IM)](#파리-퇴치-3-im)<br>
[회문 2 (String)](#회문-2-string)<br>
[문자열 비교 (String)](#문자열-비교-string)<br>
[회문 (String)](#회문-string)<br>
[글자수 (String)](#글자수-string)<br>
[가장 빠른 문자열 타이핑 (String)](#가장-빠른-문자열-타이핑-string)<br>
[괄호검사 (Stack 1)](#괄호검사-stack-1)<br>
[깊이우선탐색 (Stack 1)](#깊이우선탐색-stack-1)<br>
[파스칼의 삼각형 (Stack 1)](#파스칼의-삼각형-stack-1)<br>
[종이붙이기 (Stack 1)](#종이붙이기-stack-1)<br>
[괄호검사 2 (Stack 1)](#괄호검사-2-stack-1)<br>
[그래프 경로 (Stack 1)](#그래프-경로-stack-1)<br>
[반복문자 지우기 (Stack 1)](#반복문자-지우기-stack-1)<br>
[길찾기 (DFS and BFS)](#길찾기-dfs-and-bfs)<br>
[의석이의 세로로 말해요 (IM)](#의석이의-세로로-말해요-im)<br>
[쇠막대기 자르기 (IM)](#쇠막대기-자르기-im)<br>
[백만장자 프로젝트 (IM)](#백만장자-프로젝트-im)<br>
[비밀번호 (IM)](#비밀번호-im)<br>
[농작물 수확하기 (IM)](#농작물-수확하기-im)<br>
[Ladder 2 (IM)](#ladder-2-im)<br>
[후위표기법 변환 (Stack 2)](#후위표기법-변환-stack-2)<br>
[원소의 합이 K인 부분집합 개수 (Stack 2)](#원소의-합이-k인-부분집합-개수-stack-2)<br>
[계산기2 (후위표기식 변환 및 계산) (Stack 2)](#계산기2-후위표기식-변환-및-계산-stack-2)<br>
[Forth (Stack 2)](#forth-stack-2)<br>
[미로 (DFS and BFS)](#미로-dfs-and-bfs)<br>
[토너먼트 카드게임 (재귀, lookup table)](#토너먼트-카드게임-재귀-lookup-table)<br>
[배열 최소 합 (DFS)](#배열-최소-합-dfs)<br>
[계산기 3 (후위표기식 변환 및 계산) (icp, isp) (Stack 2)](#계산기-3-후위표기식-변환-및-계산-icp-isp-stack-2)<br>
[너비우선탐색 (Queue)](#너비우선탐색-queue)<br>
[암호생성기 (Queue)](#암호생성기-queue)<br>
[회전 (Queue)](#회전-queue)<br>
[피자 굽기 (Queue)](#피자-굽기-queue)<br>
[노드의 거리 (BFS)](#노드의-거리-bfs)<br>
[미로의 거리 (BFS)](#미로의-거리-bfs)<br>
[미로1 (BFS)](#미로1-bfs)<br>
[DFS / BFS 경로 기본 유형 정리](#dfs--bfs-경로-기본-유형-정리)<br>
[DFS 기본구현](#dfs-기본구현)<br>
[BFS 기본구현](#bfs-기본구현)<br>
[DFS 미로 경로의 거리](#dfs-미로-경로의-거리)<br>
[BFS 미로 경로의 거리](#bfs-미로-경로의-거리)<br>
[DFS 미로 경로의 개수](#dfs-미로-경로의-개수)<br>
[BFS 여러개의 출발점과 거리 (확산)](#bfs-여러개의-출발점과-거리-확산)<br>
[숫자 배열 회전 (IM)](#숫자-배열-회전-im)<br>
[오목 판정 (IM)](#오목-판정-im)<br>
[두 개의 숫자열 (IM)](#두-개의-숫자열-im)<br>
[영준이의 카드 카운팅 (IM)](#영준이의-카드-카운팅-im)<br>
[달란트2 (IM)](#달란트2-im)<br>
[2차원 배열 영역 나누기](#2차원-배열-영역-나누기)<br>
[가위바위보 (lookup table 간단한 예시)](#가위바위보-lookup-table-간단한-예시)<br>
[고대유적](#고대유적)<br>
[최대 행의 합](#최대-행의-합)<br>
[대각선의 합](#대각선의-합)<br>
[대각선의 합 (응용)](#대각선의-합-응용)<br>
[사선의 합](#사선의-합)<br>
[마이쮸 (Queue)](#마이쮸-queue)<br>
[부분집합 백트래킹 구현](#부분집합-백트래킹-구현)<br>
[순열생성 (재귀)](#순열생성-재귀)<br>
[연속한 1의 개수](#연속한-1의-개수)<br>
[atoi 구현 (String)](#atoi-구현-string)<br>

---

## APS 환경설정 (PyCharm)

---

## 1. PyCharm 설치

- **pycharm-community-2020.3.5.exe** 받기
    - [Jetbrains](https://www.jetbrains.com/) → 개발자도구(Developer Tools) → PyCharm → Download → 기타버전
        
        ![aps_1](https://user-images.githubusercontent.com/86648892/184478746-aaef594f-6a66-4c18-8076-5c57f6ca33e3.png)
        
    
    - 2020.3.5 버전 - `PyCharm Community Edition` 선택
        
        ![aps_2](https://user-images.githubusercontent.com/86648892/184478747-bd039857-5db3-4402-8ea8-fdd766db9972.png)
        
설치

![aps_3](https://user-images.githubusercontent.com/86648892/184478748-3a10afd6-ded8-41cf-a4b1-7b2325bdf66b.png)

받은 파일 실행

![aps_4](https://user-images.githubusercontent.com/86648892/184478749-449e6af4-7895-44be-a4e8-8500a5f642fd.png)

기존 버전이 있다면면 삭제 여부 결정 (기존 버전이 없으면 생략됨)

![aps_5](https://user-images.githubusercontent.com/86648892/184478750-ef815633-cd4f-4c02-9123-1b4e6e642807.png)

삭제 완료 후 Close. (기존 버전이 없으면 생략됨)

![aps_6](https://user-images.githubusercontent.com/86648892/184478751-e450c705-f24f-4fba-bae5-97e8a3083cf6.png)

![aps_7](https://user-images.githubusercontent.com/86648892/184478753-6a6511dc-af83-49f0-8f1d-54bcd73d0e43.png)

![aps_8](https://user-images.githubusercontent.com/86648892/184478755-6b4c6f47-e4af-4ff3-9ed8-d84e846a826b.png)

설치 완료

![aps_9](https://user-images.githubusercontent.com/86648892/184478756-59800e52-e844-40f4-a8e6-68505d80db0c.png)

파이참 실행 시 (이전 파이참 설정이 있는 경우 출력 됨)

---

## 2. PyCharm 기본 설정

### 2.1. 인터프리터 설정

- Python 설치 환경에 따라 인터프리터 설정이 자동으로 되지 않을 수 있기 때문에 직접 지정

![aps_10](https://user-images.githubusercontent.com/86648892/184478757-d5689409-206f-4839-9def-ae75f00604ea.png)

Customize → All settings 선택

![aps_11](https://user-images.githubusercontent.com/86648892/184478759-b19cc2cc-687d-4b2b-951e-6870a18d7f13.png)

Python Interpreter → `<No interpreter>` → Show All 선택

![aps_12](https://user-images.githubusercontent.com/86648892/184478760-a5b10495-c2ec-4f96-b15c-fa9448297c22.png)

+ 버튼 클릭

![aps_13](https://user-images.githubusercontent.com/86648892/184478761-f307ad62-9ab7-4ccf-831f-be98e130737c.png)

System interpreter → 현 파이썬 global 환경 선택 

- 빌드 테스트
    
    ![aps_14](https://user-images.githubusercontent.com/86648892/184478762-cc87fa3d-1554-4b06-af74-6cc3ffde44cd.png)
    
    Project → New Project
    
    ![aps_15](https://user-images.githubusercontent.com/86648892/184478763-253e42fc-7188-4df3-a69b-6c741493a076.png)
    
    프로젝트 폴더 경로 및 이름 자율 지정 & Previously configured interpreter 선택.
    
    ![aps_16](https://user-images.githubusercontent.com/86648892/184478764-13dcfb4f-68e5-4c38-97ac-5b2eae174114.png)
    
    소스코드에서 마우스우클릭 → Run ‘main’ 혹은 우측 상단 Run 버튼 클릭
    

- 주의
    - Python 인터프리터를 완전히 처음 실행할 경우 파이참 하단에 로딩이 진행되니 
    로딩이 끝난 후 빌드 테스트 할 것
        
        ![aps_17](https://user-images.githubusercontent.com/86648892/184478765-718e2179-0563-4954-9d28-85b7a3958a4d.png)
        

### 2.2. Terminal 설정

- bash를 기본 터미널로 사용하기 위한 설정
- git을 사용하기 위해 설정

![aps_18](https://user-images.githubusercontent.com/86648892/184478766-1d7427ca-84ed-4a50-accc-fd4b9c9a62d8.png)

1. 설정(`ctrl + alt + s`) → `Terminal` 검색 → `Shell path` 클릭

![aps_19](https://user-images.githubusercontent.com/86648892/184478767-8265625d-dc83-4cb8-b808-1fee1f39c69f.png)

2. `C → Program Files → Git → bin → bash.exe` 선택 후 OK 클릭

- ***이때 Git 폴더 안에 있는 파일 선택하지 않도록 유의***

![aps_20](https://user-images.githubusercontent.com/86648892/184478768-048d1cfe-e19f-4932-9dbb-9d67837fbd1f.png)

3. Apply → OK 클릭 

![aps_21](https://user-images.githubusercontent.com/86648892/184478769-8814e21d-6005-449f-bcdb-7cb6342a84f2.png)

![aps_22](https://user-images.githubusercontent.com/86648892/184478770-cb788d1a-926a-461e-a435-1ddaec3acfea.png)

4. 실행결과 확인

### 2.3. 기타 세팅

**폰트 사이즈 조절 설정 (마우스로 폰트 크기 조절)**

- settings → Mouse 검색 → `Change font size (Zoom) with Ctrl + Mouse Wheel` 선택

![aps_23](https://user-images.githubusercontent.com/86648892/184478772-640c8966-98ce-483f-880f-972caccaebbc.png)

**코드 에디터 폰트 설정**

- settings → font 검색 → 원하는 폰트 & 22 세팅

![aps_24](https://user-images.githubusercontent.com/86648892/184478774-d777a78c-c1cb-4ce7-b1df-91b0d56f16c4.png)

**콘솔 폰트 설정**

- settings → console font 검색 → 원하는 폰트 & 22 & 1.2 세팅

![aps_25](https://user-images.githubusercontent.com/86648892/184478775-fb83f725-8224-4a08-90ac-82747f355ba2.png)

**자동으로 git add 되는 설정 끄기**

- settings → confirmation 검색 → `Do not add` 클릭
(비활성화 되어있을 경우 안해도 됨)

<img width="970" alt="aps_26" src="https://user-images.githubusercontent.com/86648892/184478776-1f6fc0ef-6531-4d75-841a-add2a8f29ff1.png">

---

## 3. PyCharm을 활용한 실행

### 3.1. Input 연습

- input.txt

```
33
```

- p1.py

```python
import sys

sys.stdin = open('input.txt')

# 33
# => 홀수면 1, 짝수면 0
N = int(input())
result = 1 if N % 2 else 0
print(f'{result}')
```

### 3.2. 파일 실행

1. **첫 번째 방법 - 우상단의 ▶ 버튼 클릭**
    
    <img width="952" alt="aps_27" src="https://user-images.githubusercontent.com/86648892/184478777-4c5219c0-b1ea-4109-9ea4-6625d8237547.png">
    
2. **두 번째 방법 - 파일에서 우클릭 후 `Run` 클릭**
    
    <img width="952" alt="aps_28" src="https://user-images.githubusercontent.com/86648892/184478778-e7b7491a-3aa3-41a3-a5e0-167516fe712c.png">
    
- **최종적으로 위와 같은 구조로 진행**
    
    ![aps_29](https://user-images.githubusercontent.com/86648892/184478779-5f6c18d1-4c6f-4724-9702-8a7d31183fec.png)

---

## APS 디버깅 (PyCharm)

---

## 디버깅(Debugging)

디버깅(혹은 디버그)는 컴퓨터 프로그램 개발 단계 중에 발생하는 시스템의 논리적인 오류나 
비정상적 연산(버그)을 찾아내고 그 원인을 밝히고 수정하는 작업 과정

### [디버거 도구창](https://www.jetbrains.com/help/pycharm/debug-tool-window.html#steptoolbar)

### 실행

1. `.py` 파일에서 `우클릭` → `Debug 파일 이름` 클릭
2. 우측 상단의 벌레 아이콘 클릭
3. `shift + F9` 클릭

![aps_30](https://user-images.githubusercontent.com/86648892/184479544-a223c9c8-f6d0-4c2e-bcda-dada2fae2810.png)

### 1. Stepping Tools

- 디버깅을 수행할 때 유용한 다양한 도구

![aps_31](https://user-images.githubusercontent.com/86648892/184479545-17d7412e-a520-45d9-8c67-9998c689dfbd.png)

|번호   |도구의 기능   |단축키   |설명   |
|---|---|---|---|
|1   |Show Execution Point   |`Alt + F10`   |현재 실행 지점을 가리킴   |
|2  |Step Over   |`F8`   |현재 실행 지점이 있는 경우 해당 함수(메서드) 또는 파일의 다음 줄까지 이동<br>함수를 만나면 함수 안으로 들어가지 않고 함수의 실행 결과 뒷줄로 바로 이동   |
|3   |Step Into   |`F7`   |디버거가 순차적으로 실행되다가 함수(메서드)를 만나면 해당 함수 내부로 들어감   |
|4   |Step Into My Code   |`Alt + Shift + F7`   |라이브러리 소스 코드가 아닌 내가 작성한 코드의 라인만 디버거를 실행하고 싶은 경우   |
|5   |Force Step Into   |`Alt + Shift + F7`   |   |
|6   |Step Out   |`Shift + F8`   |현재 함수(메서드) 바로 뒤에 실행되는 줄로 이동<br>함수 안으로 들어갔는데 해당 밖으로 밖으로 나오고 싶은 경우 사용   |
|7   |Run to Cursor   |`Alt + F9`   |현재 커서가 위치한 줄로 바로 이동<br>단, 중간에 다른 Breakpoint가 있는 경우 해당 위치에서 멈추게 됨   |
|8   |Evaluate Expression   |`Alt + F8`   |   |

### 2. Frame

- 각 스레드의 콜스택을 살펴볼 수 있게 시각화된 형태로 제공

### 3. Variables

- 현재 실행 맥락에서 활성화된 변수를 보여주며 이를 통해 디버깅을 가능하게 하고 실시간으로 수정하며 디버깅을 할 수 있는 기능을 제공

### 4. Watches

- 특정한 맥락 변수

### 5. Console

- 종단점을 기준으로 디버거의 실행 결과 확인

## Breakpoint

### 의미

> "Breakpoints are special markers that suspend program execution at a specific point. 
This lets you examine the program state and behavior."
>
- 종단점은 특정한 순간에서의 프로그램 실행을 중단 시키는 특수한 마커이며 이를 통해 프로그램의 상태 및 동작을 검사할 수 있다. 
- 종단점만 잘 걸어도 매우 효율적인 디버깅이 가능하다.

- 예제 코드
    
    ```
    3
    2
    2 2 4 4 1
    3 3 6 6 2
    3
    1 2 3 3 1
    3 6 6 8 1
    2 3 5 6 2
    3
    1 4 8 5 1
    1 8 3 9 1
    3 2 5 8 2
    ```
    
    ```python
    import sys
    
    sys.stdin = open('input.txt')
    
    T = int(input())
    
    def solve(N):
        for k in range(N):
            r1, c1, r2, c2, color = map(int, input().split())
            for i in range(r1, r2 + 1):
                for j in range(c1, c2 + 1):
                    boxes[i][j] += color
    
    for tc in range(1, T + 1):
        boxes = [[0] * 10 for _ in range(10)]
        n = int(input())
        cnt = 0
    
        solve(n)
    
        for i in range(10):
            for j in range(10):
                if boxes[i][j] == 3:
                    cnt += 1
    
        print('#{} {}'.format(tc, cnt))
    ```
    

### 실행

- 프로그램의 실행이 중단되길 원하는 지점의 숫자 옆 공백을 클릭하고 디버거 실행
    
    <img width="961" alt="aps_32" src="https://user-images.githubusercontent.com/86648892/184479546-9ccffce8-659a-4025-9b93-31ca2595668f.png">
    

- 파일을 실행하면 아래와 같이 해당 지점에서 프로그램의 실행이 멈추게된다.
    
    ![aps_33](https://user-images.githubusercontent.com/86648892/184479548-42404023-b422-41b3-a0b2-11b95fcf4274.png)
    

### 재실행 및 종료

- 디버거 세션의 재실행은 `ctrl + F5`
- 디버거 세션의 종료는 `ctrl + F2`

## 디버깅 활용 예제

### 1️. Breakpoint 설정

![aps_34](https://user-images.githubusercontent.com/86648892/184479550-7eb99508-eafa-4eb6-8516-2deb899bbf18.png)

- 디버깅을 원하는 지점(라인)의 오른쪽 공백 부분을 체크하여 Breakpoint를 걸어줌
- **condition에 `i==1 and j==1` 과 같이 breakpoint 조건을 넣을 수 있음**

### 2️. Step Into(`F7`)

**종단점에서 실행이 중지된 프로그램에서 `F7`을 누르면 다음 실행 될 라인으로 이동**

이때 `Variables`를 보면 현재 실행 환경(전역)의 변수 목록을 확인할 수 있음

![aps_35](https://user-images.githubusercontent.com/86648892/184479551-cfae5b53-f17a-4fa1-868c-1be5c0dada59.png)

**만약 코드의 실행 과정에서 함수를 만나면 함수 내부로 이동**

- 이때 `Frames`를 보면 현재 실행 환경이 전역 → 함수 내부로 이동 했기 때문에 
변수 목록이 변경 된 것을 확인할 수 있음
    
    <img width="961" alt="aps_36" src="https://user-images.githubusercontent.com/86648892/184479553-e275d413-838a-4246-8772-8713565e204e.png">
    
    전역 
    
    <img width="961" alt="aps_37" src="https://user-images.githubusercontent.com/86648892/184479555-58cf5a3f-ce71-4115-852f-fbd9e49780d1.png">
    
    함수 내부
    

### 3️. Step out(`Shift + F8`)

**함수 내부에서 결과를 실행하는 과정을 종료하고 싶다면 Step out 기능을 사용**

<img width="961" alt="aps_38" src="https://user-images.githubusercontent.com/86648892/184479557-91ec7443-8472-4fe9-b649-092e3ddcf50f.png">

함수 내부에서 디버거 실행 중

<img width="961" alt="aps_39" src="https://user-images.githubusercontent.com/86648892/184479558-2e8094e3-93d1-43cf-b555-527cc30ce79c.png">

Step out을 통해 함수 바깥으로 빠져나온 모습

### 4️. Step over(`F8`)

**특정한 함수의 실행 과정을 거치지 않고 바로 다음으로 넘어가고 싶은 경우 Step over 기능을 사용**

<img width="961" alt="aps_40" src="https://user-images.githubusercontent.com/86648892/184479559-4a96b3c2-8a5a-44c8-ab6c-7943f0653d9c.png">

여기서 F7를 사용하게되면 `solve` 함수 내부로 들어가게 됨

<img width="961" alt="aps_41" src="https://user-images.githubusercontent.com/86648892/184479560-300acd17-2280-44ee-966d-b3bc52271c1c.png">

하지만 Step over(`F8`)를 사용하게 되면 함수의 실행 결과를 거친 이후 바로 다음 줄로 넘어가 실행 가능

### 5️. Run to cursor(`Alt + F9`)

**현재 실행 중인 지점으로부터 특정한 지점으로 바로 이동하고 싶은 경우 Run to cursor 기능을 사용**

- 이동하고 싶은 라인의 코드의 일부분을 드래그 한 후 Run to cursor 버튼 클릭
- (c.f. 모든 상황에 적용 가능한 것은 아님)
    
    <img width="961" alt="aps_42" src="https://user-images.githubusercontent.com/86648892/184479561-28a05027-d4f7-439c-8a6b-742f55fca5b8.png">
    
    14번째 줄에서 19번째 줄로 바로 이동하고 싶다!
    
    <img width="961" alt="aps_43" src="https://user-images.githubusercontent.com/86648892/184479562-675c6e43-e57d-4177-a33c-73a54fbdacbf.png">
    
    Run to cursor 기능을 통해 바로 이동 가능
    

### 6️. Watches

**특정한 함수의 맥락에서 다른 (ex. 전역) 맥락의 변수 등을 확인하고 싶은 경우 Watches를 활용**

<img width="961" alt="aps_44" src="https://user-images.githubusercontent.com/86648892/184479565-92140094-678a-4cd1-b144-931a188f2cfa.png">

<img width="961" alt="aps_45" src="https://user-images.githubusercontent.com/86648892/184479567-991143d7-3f2f-4ce6-8861-3955ad50fe08.png">

### 7️. 이차원 배열 편하게 보기

왼쪽의 토글 버튼을 클릭하면 2차원 배열에서 각 행에 해당하는 리스트를 한 줄로 펼쳐서 보여주기 때문에 매우 편하게 확인 가능

![aps_46](https://user-images.githubusercontent.com/86648892/184479569-eb82bf06-4ebf-4264-a5e3-c114f9f98176.png)

## 참고 자료

[Debug Wikipedia](https://ko.wikipedia.org/wiki/%EB%94%94%EB%B2%84%EA%B7%B8)

[Jetbrains Debug PyCharm](https://www.jetbrains.com/help/pycharm/debugging-code.html)

---

## APS 문제풀이 Guidelines

---

## 문제풀이 과정의 목표

### 빈틈없이!!!!!!

- **입력 TC를 처리하여 정확한 출력을 내보내는 것**
- A형까지는 모든 테스트케이스를 빠짐없이 통과할 수 있도록 하는 것에 초점을 두어야 함
    - 유려한 알고리즘을 짜겠다는 생각은 일단 버리자
    - 숨겨져 있는 테스트케이스들도 통과할 수 있는 실력을 갖추자

## 문제풀이 유형

### 1. 아이디어

- 아이디어를 내고 이를 구현하는 능력
- 1, 2차원 list
    - 다중 loop
    - if

### 2. 알고리즘

- 누군가 아이디어를 체계화시킨 것
- 템플릿
    - 자료구조
        - 스택
        - 큐
        - 등등
    - BFS (너비 우선 탐색)
    - DFS (깊이 우선 탐색)
    - 등등
- 유형을 잘 이해하고
    - 잘 응용하는 능력

## 문제풀이 주의사항

- Sample Case는 맞지만 부분정답이 나오는 경우
    - 문제풀이 방향성이 잘못된 것이다!
    - 예외처리, if조건 등등 덕지덕지 추가한 것은 그저 누더기가 되어 어찌저찌 맞추더라도 다른 테스트케이스에는 작동하지 않을 수 있음
- 범위 설정에서 실수 많이함
- 코테 문제 출제의 대부분은 TC 설계에 시간을 보낸다
    - TC는 더럽게 내는 것이 출제자의 목표
    - TC 설계
        - 30%는 쉬운 상황
        - 40%는 경계값
        - 30%는 범위나 이런 것들 등에서 극한 상황으로 줌
- Sample Case들을 보면서 문제풀이를 어떤 방향으로 할지 출제자의 의도를 파악

### 1. 처음 보는 문제를 이해하고

### 2. 모든 TC를

### 3. 제한조건 내에 정확히 처리

### 유형별 연습은 가능하지만 정해진 유형은 없다

## 문제풀이 단계

- 문제 읽기
    - 1회독
        - 3분정도 훑으며 TC 손코딩
    - 2회독
        - 조건이나 특이사항 체크
    - 3회독
        - 지양하자
        - 디버깅까지 해봤는데 전혀 감이 안올 때
        - 새출발한다는 느낌으로
        - 이런 경우는 연습 때 겪어보자
- 접근방법 구상
    
    <img width="741" alt="aps_47" src="https://user-images.githubusercontent.com/86648892/184578972-130d8009-6aa1-45f0-b043-7de0ca62c6d6.png">
    
    - 알고리즘 유형 적용 가능한지 체크
    - 그게 아니라면 아이디어 구현
        - 규칙성 발견이 어렵다면
            - 가능한 모든 경우 완전탐색
                - big o notation 기준 `n^2` 는 시간 내에 못할 확률 높음
            - 전체문제가 아닌 일부분으로 쪼개거나 단계를 나누어 생각
            - 혹은 생각의 방향을 반대로 해보는 경우
    - 컴퓨터는 단계별로 반복하며 진행하는 존재
        - 인간의 뇌적 사고 방식으로 코드를 짜려다보면 난관에 봉착할 수 있다
- 핵심코드 손코딩
    - 시각적으로
    - 실명의 변수
    - 범위
- 코드구현
- 디버깅 및 개선
    - 공개된 TC와 답이 내 코드로 구현이 되지 않을 때
        - 이런 경우는 오히려 해피한 경우

<img width="840" alt="aps_48" src="https://user-images.githubusercontent.com/86648892/184578984-f615e8ee-fc48-4d89-9997-d58314cd87f0.png">

## Input 처리

<img width="840" alt="aps_49" src="https://user-images.githubusercontent.com/86648892/184578985-396ccadb-add0-4883-b1d5-174e36f11538.png">

<img width="824" alt="aps_50" src="https://user-images.githubusercontent.com/86648892/184578987-b9cc4fcc-54d2-4b35-9568-f2233039e2fe.png">

---

## APS 유형 Reminder

---

## 접근 방식

- ***규칙성*이나 *아이디어*를 발견하여 코드를 간단하게 구현할 수 있는 방향을 생각**
- ***구현* 자체에 초점이 맞춰져 있는 경우 필요한 요소들이 무엇인지 생각하고, 현재 *어떤 파트가 어떤 일을 담당*하는지 명료하게 생각하며 진행**
- ***테스트케이스가 더러운 경우* 예외가 될 수 있는 경우들을 생각해보며 *예외처리*를 잘해줄 것**
- **이외 *대표적인 개념이나 유형*의 경우 개념을 활용하여 풀어내볼 것**

## 유형
### IM
- **2차원 배열** 접근 및 순회(for문, 인덱스 활용)
- s, e **인덱스** 가지고 놀기
- 2차원 배열 **4방향 탐색**(델타 검색 활용)
- **정렬**하기
- **탐색**하기
- **stack, queue**같은 기본적 자료형 활용
- **재귀 (1. 종료조건 2. 단위작업 3. 하부호출)**
- **백트래킹 (재귀 + 가지치기(pruning))**
- **DFS**와 **BFS**

---

## 입력연습

```python
'''
# 입력파일에 저장할 값
hello
45
1 2 3
3.14
1.2 2.3 3.4
one two three
1 2 45 43
1234
4
1011
1001
0001
1000
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
'''

# 1.문자열 입력 받기
# st = 'hello'
st = input()

# 2.정수형 변수 입력 받기
# N = 45
N = int(input())
# A, B, C = 1, 2, 3
n1, n2, n3 = map(int, input().split())

# 3.실수형 변수 입력 받기
# F = 3.14
# A, B, C = 1.2, 2.3, 3.4
F = float(input())
f1, f2, f3 = map(float, input().split())

# 4.한 줄에 있는 공백으로 구분된 단어들을 각각 문자열로 리스트에 저장하기
# lst = ['one', 'two', 'three']
lst4 = list(input().split())

# 5.한 줄에 있는 공백으로 구분된 숫자들을 각각 숫자로 리스트에 저장하기
# lst = [1, 2, 45, 43]
lst5 = list(map(int, input().split()))

# 6.한 줄에 있는 공백없는 한자리 숫자들을 각각 숫자로 리스트에 저장하기
# lst = [1, 2, 3, 4]
lst6 = list(map(int, input()))

# 7.2차원 (N*N) 공백없는 한자리 숫자들을 2차원 arr에 저장
# 4
# 1011
# 1001
# 0001
# 1000
N = int(input())
arr7 = [list(map(int, input())) for _ in range(N)]

# 8.2차원 (N*N) 정수값을 2차원 arr에 저장 (N값과 arr값)
# 4
# 1 2 3 4
# 5 6 7 8
# 9 10 11 12
# 13 14 15 16
N = int(input())
arr8 = [list(map(int, input().split())) for _ in range(N)]

# 9.(입력은 아니지만) 0값 10개를 가진 1차원 lst 생성
# lst = [0, 0, 0, 0, 0, 0, 0, 0, 0]
arr9 = [0]*10

# 10.(입력은 아니지만) 0값 3 * 3 개를 가진 2차원 arr생성
# arr = [[0, 0, 0],[0, 0, 0],[0, 0, 0]]
arr10 = [[0]*3 for _ in range(3)]

# 11.위의 2차원 arr를 1 ~ N(행/열)에 저장(사방을 0으로 감싸기)
# 0 0 0 0 0
# 0 1 2 3 4 0
# 0 5 6 7 8 0
# 0 9 10 11 12 0
# 0 13 14 15 16 0
# 0 0 0 0 0
N = int(input())
arr11 = [[0]*(N+2)] + [[0] + list(map(int, input().split())) + [0] for _ in range(N)] + [[0]*(N+2)]

print('End')
```

---

## View (List 1)

<img width="934" alt="aps_51" src="https://user-images.githubusercontent.com/86648892/187015959-412ee432-8878-4f18-a83a-18dc6555e97b.png">

<img width="926" alt="aps_52" src="https://user-images.githubusercontent.com/86648892/187015968-2098c172-7630-4220-9562-c1f25435366c.png">

```python
for test_case in range(1, 11):
    N = int(input())
    buildings = list(map(int, input().split()))
    ans = 0
    # 양쪽 2씩 건물이 없으므로 인덱스 범위는 2에서 N-3
    for i in range(2, N - 2):
        # 가운데 빌딩이 가장 큰 경우에만 조망권 세대 존재
        if buildings[i] > buildings[i - 1] and buildings[i] > buildings[i - 2] and buildings[i] > buildings[i + 1] and buildings[i] > buildings[i + 2]:
            # 양옆 건물들 중 가장 높은 건물과의 차이가 조망권 세대 수
            d1 = buildings[i] - buildings[i - 1]
            d2 = buildings[i] - buildings[i - 2]
            d3 = buildings[i] - buildings[i + 1]
            d4 = buildings[i] - buildings[i + 2]
            min_d = d1
            for j in [d1, d2, d3, d4]:
                if j < min_d:
                    min_d = j
            ans += min_d
    print(f'#{test_case} {ans}')
```

---
## Gravity (List 1)

<img width="903" alt="aps_53" src="https://user-images.githubusercontent.com/86648892/187016073-c3f08130-e40f-45c0-bef0-b785fc4d65c2.png">

<img width="915" alt="aps_54" src="https://user-images.githubusercontent.com/86648892/187016076-b8416751-c948-4c24-bfce-1094c3455ad7.png">

```python
# 더 작은 애가 있는만큼 떨어질 것이니 우측에 더 작은 애가 있는만큼 cnt를 올려주면 됨

T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    lst = list(map(int, input().split()))
    ans = 0
    for i in range(N):
        cnt = 0
        for j in range(i+1, N):
            if lst[i] > lst[j]:
                cnt += 1
        if ans < cnt:
                ans = cnt
    print(f'#{test_case} {ans}')
```

---

## Baby-Gin Game (List 1)

<img width="900" alt="aps_55" src="https://user-images.githubusercontent.com/86648892/187016138-84a403eb-f2d0-4fb2-85cb-60d544598fdd.png">

```python
T = int(input())
for testcase in range(1, T+1):
    lst = list(map(int, input()))
    cnts = [0]*12

    ans = 0
    # cnts 배열에 빈도수 표기
    for n in lst:
        cnts[n] += 1

    # tri, run 찾기
    i = 0
    while i < 10:
        if cnts[i] >= 3:
            ans += 1
            cnts[i] -= 3
        elif cnts[i]>=1 and cnts[i+1]>=1 and cnts[i+2]>=1:
            ans += 1
            cnts[i] -= 1
            cnts[i + 1] -= 1
            cnts[i + 2] -= 1
        else:
            i += 1
    print(f'#{testcase} {ans//2}')
```

---

## min max (List 1)

<img width="903" alt="aps_56" src="https://user-images.githubusercontent.com/86648892/187016319-a2a2fdc9-646e-4323-9074-adf7a4ce6e2d.png">

```python
T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    lst = list(map(int, input().split()))

    # 초기값 설정: 주어진 조건 확인
    # 주어지는 수의 범위가 1이상 1000000이하
    # mx에 0을 주고 mn이 1000000을 주면 갱신될 수 밖에 없음
    mx = 0
    mn = 1000000
    for n in lst:
        if mx < n:
            mx = n
        if mn > n:
            mn = n
    print(f'#{test_case} {mx - mn}')
```

---

## 구간합 (List 1)

<img width="907" alt="aps_57" src="https://user-images.githubusercontent.com/86648892/187016392-d388d951-9aa2-4646-87d2-c5e0bdcd80cd.png">

<img width="921" alt="aps_58" src="https://user-images.githubusercontent.com/86648892/187016396-1d880ee4-58df-4c47-acea-1ec670b452aa.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())
    lst = list(map(int, input().split()))
    
    # (2) 추가 / 제거되는 연산만 수행
    sm = 0
    for i in range(M):
        sm += lst[i]
    mn = mx = sm

    for i in range(M, N):
        sm = sm + lst[i] - lst[i-M]
        if mx < sm:
            mx = sm
        if mn > sm:
            mn = sm

    # (1) 모든 합을 구하는 방법
    '''
    mx = 0
    mn = 10000*M
    for i in range(N-M+1):
        sm = 0
        for j in range(i, i+M):
            sm += lst[j]
        if mx < sm:
            mx = sm
        if mn > sm:
            mn = sm
    '''
    print(f'#{test_case} {mx-mn}')

'''
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())
    lst = list(map(int, input().split()))

    mx = 0
    mn = 10000*M
    for i in range(N-M+1):
        sm = 0
        for j in range(i, i+M):
            sm += lst[j]
        if mx < sm:
            mx = sm
        if mn > sm:
            mn = sm
    print(f'{test_case} {mx-mn}')
'''
```

---

## 숫자 카드 (List 1)

<img width="895" alt="aps_59" src="https://user-images.githubusercontent.com/86648892/187016482-3aa13418-3336-4dc1-a609-0d795c09d5ec.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    lst = list(map(int, input()))

    # 0부터 9까지의 카운트 배열 생성
    cnts = [0] * 10
    # lst의 값을 꺼내서 cnts 값을 1씩 추가
    for i in lst:
        cnts[i] += 1
    # 0부터 9중의 가장 높은 숫자의 인덱스를 찾아야함
    # 초기값 0으로 설정
    idx = 0
    for i in range(1, 10):
        # 현재의 최대값보다 더 큰 값이 나온다면 (같은 값일 경우 더 큰 값을 기준으로 하라고 했으니 = 추가)
        if cnts[idx] <= cnts[i]:
            idx = i
    # count의 인덱스: 해당 숫자, count의 인덱스 값: 장 수
    print(f'#{test_case} {idx} {cnts[idx]}')
```

---

## 전기버스 (List 1)

<img width="901" alt="aps_60" src="https://user-images.githubusercontent.com/86648892/187016561-b6d824c9-8045-4bcd-85b1-213c23bcc7cd.png">

<img width="897" alt="aps_61" src="https://user-images.githubusercontent.com/86648892/187016566-658829ae-23a9-4d7b-bd2f-09cf68c3c3d6.png">

```python
T = int(input())
for test_case in range(1, T+1):
    K, N, M = map(int, input().split())
    lst = list(map(int, input().split()))

    # 출발점을 포함한 정류장 표현 배열 생성
    busstop = [0] * (N+1)

    # 충전기 위치 1로 표시
    for i in lst:
        busstop[i] += 1

    # charge는 충전기 개수, start는 버스 출발 지점, cnt는 필요 충전횟수
    charge = M
    start = 0
    cnt = 0

    # 충전기가 더 남아있지 않을 때는 판단 멈춤
    while charge > 0:
        # 출발지점 기준 이동가능 위치 슬라이싱
        if 1 in busstop[start+1 : start+K+1]:
            # 아직 도착하지 않을 거리라면 (충전기가 더 필요할테니까)
            if start + K < N:
                cnt += 1
                # 해당 부분 가장 오른쪽 정류장 idx를 새로운 출발 지점(start)으로 지정
                # 또한 해당 부분 안에 있는 충전기 수만큼 충전기 수 빼주기
                idx = 0
                for i in range(start+1, start+K+1):
                    if busstop[i] == 1:
                        charge -= 1
                        idx = i
                start = idx
            else:
                break
        else:
            # 필요 거리 내에 충전기 없을 시 cnt를 0으로 부여, charge=0은 while loop 종료용
            charge = 0
            cnt = 0
    print(f'#{test_case} {cnt}')
```

---

## Flatten (List 1)

<img width="907" alt="aps_62" src="https://user-images.githubusercontent.com/86648892/187016650-94ae1631-544b-4c5b-be98-1ecb07003ff4.png">

<img width="870" alt="aps_63" src="https://user-images.githubusercontent.com/86648892/187016652-ec368f6b-ea7e-4653-8d72-ab1431197267.png">

<img width="875" alt="aps_64" src="https://user-images.githubusercontent.com/86648892/187016655-61a6f889-110d-4890-9135-f36b11ea1a6f.png">

<img width="934" alt="aps_65" src="https://user-images.githubusercontent.com/86648892/187016656-2269e9fb-23e7-4f16-b93e-54943f8c2808.png">

```python
for test_case in range(1, 11):
    N = int(input())
    lst = list(map(int, input().split()))

    # 가장 높은 블록과 낮은 블록의 차이값
    ans = 0
    # N만큼 dump (마지막 dump시 lst[mx_idx] - lst[mn_idx]가 0이나 1이 되는 경우를 위해 =을 추가)
    while N >= 0:
        # 가장 높은 블록과 낮은 블록의 인덱스 값 초기화
        mx_idx = 0
        mn_idx = 0

        # 주어진 블록 길이만큼 왼쪽부터 차례대로 해당 작업을 수행
        for i in range(1, len(lst)):
            # 오른쪽 블록이 더 크거나 같으면 해당 블록이 max 인덱스 지점
            if lst[mx_idx] <= lst[i]:
                mx_idx = i
            # 오른쪽 블록이 더 작거나 같으면 해당 블록이 min 인덱스 지점
            if lst[mn_idx] >= lst[i]:
                mn_idx = i

        # dump를 계속 진행하기 위해서는 가장 높은 블록과 낮은 블록의 차이가 2이상 이어야함
        # 그렇지 않을 경우 현재 max와 min값의 차이를 반환하고 dump 종료
        if lst[mx_idx] - lst[mn_idx] > 1:
            # 현재 dump상황까지의 max min 차이 저장
            ans = lst[mx_idx] - lst[mn_idx]
            # 가장 높은 블록 하나 빼주고
            lst[mx_idx] -= 1
            # 가장 낮은 블록 하나 더해주고
            lst[mn_idx] += 1
            # dump 횟수 차감
            N -= 1
        else:
            ans = lst[mx_idx] - lst[mn_idx]
            break
    print(f'#{test_case} {ans}')
```

---

## 정렬 연습 (List 1)

<img width="911" alt="aps_66" src="https://user-images.githubusercontent.com/86648892/187016709-5be3b54c-0ca8-4c59-a801-6ee26cc05302.png">

```python
# Bubble Sort
def BubbleSort(a, N):
    for i in range(N-1, 0, -1): # 구간의 맨 끝 인덱스부터 비교 시작
        for j in range(i): # 인접 원소 중 왼쪽 원소 인덱스까지 비교
            if a[j] > a[j+1]: # 오름차순, 더 큰 수를 오른쪽으로
                a[j], a[j+1] = a[j+1], a[j]
    return a

N = int(input())
arr1 = [55, 7, 78, 12, 42]
print(BubbleSort(arr1, N))

# Counting Sort
# 입력된 배열의 카운트 값을 누적시킨 후
# 입력된 값을 인덱스로 활용 -> 해당 값에 해당하는 누적 카운트에 접근
# 접근한 누적 카운트를 인덱스로 활용 -> 해당 인덱스에 정렬용 배열 속으로 데이터 삽입
def CountingSort(A, B, k):
    # A는 입력할 배열 (k는 데이터 최대값)
    # B는 정렬된 배열
    # C는 카운트 배열
    C = [0]*(k+1) # 해당 인덱스에 k까지의 수를 나타내야 하므로 인덱스는 k+1까지
    
    # 카운트 배열 값 채우기
    for i in range(0, len(A)):
        C[A[i]] += 1

    # 카운트 배열 누적으로 전환
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    # 원본을 뒤에서부터 빼주면서 정렬
    # 왼쪽 끝의 값까지 확인해야 하므로 end 범위는 -1까지
    for i in range(len(B)-1, -1, -1):
        C[A[i]] -= 1
        # 해당 카운트의 위치에 값 삽입
        B[C[A[i]]] = A[i]
    return B

k = int(input())
arr2 = [4, 3, 1, 1, 7, 6, 7, 5, 7]
tmp = [0]*len(arr2)
print(CountingSort(arr2, tmp, k))

# Selection Sort

def SelectionSort(a, N):
    for i in range(N-1):
        minIdx = i
        for j in range(i+1, N):
            if a[minIdx] > a[j]:
                minIdx = j
        a[i], a[minIdx] = a[minIdx], a[i]
    return a

N = int(input())
arr3 = [55, 7, 78, 12, 42]
print(SelectionSort(arr3, N))
```

---

## 델타검색 (List 2)

<img width="894" alt="aps_67" src="https://user-images.githubusercontent.com/86648892/187016794-826ddd4e-ed9a-43ef-b341-fda55498cd7d.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    lst = [list(map(int, input().split())) for _ in range(N)]
    di = [0, 1, 0, -1]
    dj = [1, 0, -1, 0]
    ans = 0
    for i in range(N):
        for j in range(N):
            for k in range(4):
                ni = i + di[k]
                nj = j + dj[k]
                if 0<=ni<N and 0<=nj<N:
                    ans += abs(lst[i][j] - lst[ni][nj])
    print(f'#{test_case} {ans}')

'''
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    lst = [list(map(int, input().split())) for _ in range(N)]
    ans = 0
    for i in range(N):
        for j in range(N):
            for di, dj in ((-1,0), (1,0), (0,-1), (0,1)):
                ni, nj = i+di, j+dj
                if 0<=ni<N and 0<=nj<N:
                    ans += abs(lst[i][j]-lst[ni][nj])
    print(f'#{test_case} {ans}')
'''
```

---

## 부분집합 합 (비트연산) (List 2)

<img width="902" alt="aps_68" src="https://user-images.githubusercontent.com/86648892/187016909-511c7562-ffda-4c0f-acd3-52cd4896310f.png">

```python
'''
10개의 정수를 입력 받아 부분집합의 합이 0이 되는 것이 존재하는지를 계산하는 함수를 작성해보자.
입력
2
19 6 16 19 15 16 8 13 16 10
-20 -6 -13 3 -19 -9 19 -3 9 4
출력
#1 0
#2 1
'''
# 합해서 특정값 k가 된다고 생각해보자
# 해당 index의 값을 사용하지 않는다(0), 사용한다(1)로 각각의 원소에 적용할 수 있음

# 1) bit는 2^n-1까지의 이진수들 # 그리고 이 bit는 각각의 부분집합을 나타내는 숫자 (사용여부 0, 1로 나타내는)
# 2) 부분집합 합이 0이 되는지 판단하기 위해 sm 초기화
# 3) bit >> i # bit 수를 i만큼 오른쪽으로 shift하여 해당 자리 수의 비트 값만 남겨놓고 1과 & 연산
# 3-1) 해당 자리의 비트 수가 1이면, 즉 있으면 True, 그리고 해당 값을 sm에 더해줌
# 3-2) 해당 자리의 비트 수가 0이면, 즉 없으면 False, 그리고 해당 값을 sm에 더해주지 않음
# List의 Index는 편의상 뒤에서부터 부여하자 (N-1, N-2, ... , 3, 2, 1, 0)
T = int(input())
for test_case in range(1, T+1):
    lst = list(map(int, input().split()))
    N = len(lst) #N bit (Lst member: N)
    ans = 0
    k = 0 # 찾아야 될 숫자를 k라 가정
    '''
    for i in range(1<<N):
        sm = 0
        # 내가 보려는 자리를 지칭
        for j in range(N):
            if i & (1<<j):
                sm += lst[j]
    '''
    for bit in range(1, 2**N): # == 1 << N
        sm = 0
        for i in range(0, N): # every Lst index
            if (bit>>i) & 1: # i만큼 shift하여 해당 인덱스 값만 판단
                sm += lst[i] # 부분집합에 있으면 더해줌
        if sm == k: # 부분집합의 합이 목표값(0)과 같다면
            ans += 1 # 맞음을 표시하는 1 표시
            break
    print(f'#{test_case} {ans}')
```

---

## 달팽이 숫자 (List 2)

<img width="894" alt="aps_69" src="https://user-images.githubusercontent.com/86648892/187016995-74284499-0331-475a-b066-f1d726ee3251.png">

<img width="897" alt="aps_70" src="https://user-images.githubusercontent.com/86648892/187017002-b407e939-4ff1-45ce-89e8-1b153f478b88.png">

```python
'''
수업 풀이를 통한 개선점
1) array에서 값을 빼내 출력할 때 언패킹 연산자(*) 활용
2) % 연산자를 활용한 방향 전환
3) di, dj 초기화 위치
4) cnt += 1을 while 바깥에 한번 진행해주고 while의 범위를 <=으로 설정하여 직관성 상승
'''

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    # 초기 배열 생성
    arr = [[0] * N for _ in range(N)]
    # direction은 우->하->좌->상 순 시계방향으로 0, 1, 2, 3
    direction = 0
    i, j = 0, 0
    di = [0, 1, 0, -1]
    dj = [1, 0, -1, 0]
    # 출발 지점에 1을 놓고 cnt도 1인 상태로 시작
    cnt = 1
    arr[0][0] = 1
    # cnt 값을 최신화하고 넣어주는 logic이니까 가령 4*4인 경우 15일 때까지만 loop 허용(안에 들어가서 16이 될테니)
    while cnt < N*N:
        # 현재 방향 기준으로 다음 좌표 설정
        ni = i + di[direction]
        nj = j + dj[direction]
        # 좌표가 전체 범위를 넘지 않는다면
        if 0 <= ni < N and 0 <= nj < N:
            # 그리고 도착할 다음 좌표의 값이 0이라면 (아직 도착하지 않은 곳이라면)
            if arr[ni][nj] == 0:
                # 카운트 값을 올려주고 해당 값을 도착할 값에 부여, 그리고 새로운 좌표를 기준점으로 업데이트
                cnt += 1
                arr[ni][nj] = cnt
                i, j = ni, nj
            # 조건이 만족하지 않는 경우 (도착할 값이 0이 아닌 경우)
            else:
                # 방향이 위로 향하고 있는 경우
                if direction == 3:
                    # 잘못 최신화된 ni, nj 좌표를 다시 바로 잡아주고
                    ni -= di[direction]
                    nj -= dj[direction]
                    # 상 -> 우로 방향 전환
                    direction = 0
                    # 다시 ni, nj 최신화
                    ni += di[direction]
                    nj += dj[direction]
                    # 이동 작업 수행
                    cnt += 1
                    arr[ni][nj] = cnt
                    i, j = ni, nj
                # 다른 방향인 경우
                else:
                    ni -= di[direction]
                    nj -= dj[direction]
                    # 방향값에 1을 더해주어 시계방향으로 방향 전환
                    direction += 1
                    ni += di[direction]
                    nj += dj[direction]
                    cnt += 1
                    arr[ni][nj] = cnt
                    i, j = ni, nj
        # 조건이 만족하지 않는 경우 (범위를 초과한 경우)
        else:
            if direction == 3:
                ni -= di[direction]
                nj -= dj[direction]
                direction = 0
                ni += di[direction]
                nj += dj[direction]
                cnt += 1
                arr[ni][nj] = cnt
                i, j = ni, nj
            else:
                ni -= di[direction]
                nj -= dj[direction]
                direction += 1
                ni += di[direction]
                nj += dj[direction]
                cnt += 1
                arr[ni][nj] = cnt
                i, j = ni, nj
    print(f'#{test_case}')
    for line in arr:
        for number in line:
            print(number, end = ' ')
        print()

'''
교수님 풀이

# 고정된 값이니 한 번만 초기화하는게 속도에 유리하므로 밖으로 빼주자
di = [0, 1, 0, -1]
dj = [1, 0, -1, 0]

T = int(input())
# T = 10
for test_case in range(1, T+1):
    N = int(input())
    arr = [[0]*N for _ in range(N)]

    i = j = dr = 0
    cnt = 1
    arr[i][j] = cnt
    # 내 풀이와는 다르게 밖에서 cnt += 1을 해주고 while 범위에 =을 붙여줌
    cnt += 1

    while cnt <= N*N:
        ni, nj = i+di[dr], j+dj[dr] # 이동할 좌표계산
        if 0<=ni<N and 0<=nj<N and arr[ni][nj]==0: # 기록가능: 범위내이고 0이면
            i, j = ni, nj # 현재좌표 이동
            arr[i][j] = cnt
            cnt += 1
        else: # 불가능 -> 방향전환 후 기록
            # dr을 %를 통해 바꾸는 방법 알아두자
            dr = (dr+1)%4

    print(f'#{test_case}')
    for lst in arr:
        # 언패킹 연산자(asterisk) 활용
        print(*lst)
'''
```

---

## Sum 행열대각선합 (List 2)

<img width="860" alt="aps_71" src="https://user-images.githubusercontent.com/86648892/187017088-91aea57b-3048-475b-ba49-ec613c8e4ac4.png">

<img width="935" alt="aps_72" src="https://user-images.githubusercontent.com/86648892/187017089-b97d78fe-3440-4a87-a50b-59e7896a092a.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = 100
    arr = [list(map(int, input().split())) for _ in range(N)]

    rsMax = 0 # 행의 합 최대
    lsMax = 0 # 열의 합 최대
    dsMax = 0 # 대각선 합 최대
    ans = 0

    # 행 최대 합 구하기
    for i in range(N):
        rs = 0
        for j in range(N):
            rs += arr[i][j]
            if rs > rsMax:
                rsMax = rs

    # 열 최대 합 구하기
    for i in range(N):
        ls = 0
        for j in range(N):
            ls += arr[j][i]
            if ls > lsMax:
                lsMax = ls

    # 대각선 최대 합 구하기
    ds1 = 0 # 좌->우 대각선
    ds2 = 0 # 우->좌 대각선
    for i in range(N):
        ds1 += arr[i][i]
        ds2 += arr[N-1-i][i]
        if ds1 >= ds2:
            dsMax = ds1
        else:
            dsMax = ds2

    # 셋 중 최대 구하기
    if rsMax >= lsMax and rsMax >= dsMax:
        ans = rsMax
    elif lsMax >= rsMax and lsMax >= dsMax:
        ans = lsMax
    else:
        ans = dsMax

    print(f'#{test_case} {ans}')

'''
# 같은 logic (행, 열, 각 대각선 합 구하고 비교)
# 더 간단한 표기

T = int(input())
for test_case in range(1,T+1):
    N = 100
    arr = [list(map(int, input().split())) for _ in range(N)]

    ans = s3 = s4 = 0
    for i in range(N):
        s1 = s2 = 0
        for j in range(N):
            s1 += arr[i][j] # 행의 합
            s2 += arr[j][i] # 열의 합
        if ans < s1: ans = s1
        if ans < s2: ans = s2

        s3 += arr[i][j] # 좌 -> 우 대각선 합
        s4 += arr[i][N-1-i] # 우 -> 좌 대각선 합
    if ans < s3: ans = s3
    if ans < s4: ans = s4

    print(f'#{test_case} {ans}')
'''

'''
# 합 구하기 및 최대합 비교를 위해 max(), sum() 활용
# 대각선 합을 구하기 위해 list comprehension 활용
# 행과 열을 바꿔주기 위해 zip() 활용

T = int(input())
for test_case in range(1,T+1):
    N = 100
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 양 대각선의 합을 list comprehension과 sum()을 통해 구하고, 이 중 더 큰 값을 ans에 넣어줌
    ans = max(sum([arr[i][i] for i in range(N)]), sum([arr[i][N-1-i] for i in range(N)]))
    # 행과 열에 대해 판단할 것으로 2번 진행
    for _ in range(2):
        # 처음은 각 행의 값 리스트에 대해 판단
        for lst in arr:
            sm = sum(lst)
            ans = max(ans, sm)
        # 각 행들에 대한 판단이 끝난 후, *를 통해 arr의 각 행을 언패킹하고, 각 행들의 모음을 list(zip())함으로써 arr의 열들에 있던 순자의 순서를 행으로 변경
        # 그리고 이 바뀐 arr(열 판단용)를 다시 for문을 통해 각 열의 합 구해주고, 최대합 여부 판단
        arr = list(zip(*arr))

    print(f'#{test_case} {ans}')
'''
'''
# zip 예시

arr = [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]
print(list(zip(*arr))) # [(1, 5, 9, 13), (2, 6, 10, 14), (3, 7, 11, 15), (4, 8, 12, 16)]
'''
```

---

## 색칠하기 (List 2)

<img width="916" alt="aps_73" src="https://user-images.githubusercontent.com/86648892/187022100-4b866dd0-66c3-449e-8367-bc878212459a.png">

<img width="932" alt="aps_74" src="https://user-images.githubusercontent.com/86648892/187022103-b1ec7954-17fe-4df1-9917-993d4698ada3.png">

```python
T = int(input())
for test_case in range(1, T+1):
    C = int(input())
    N = 10
    arr = [[0]*(N) for _ in range(N)]
    ans = 0
    for _ in range(C):
        r1, c1, r2, c2, color = map(int, input().split())
        for i in range(r1, r2+1):
            for j in range(c1, c2+1):
                arr[i][j] += color
    for i in range(N):
        for j in range(N):
            if arr[i][j]==3:
                ans += 1
    print(f'#{test_case} {ans}')
```

---

## 원소의 합이 K인 부분집합 개수 (비트연산) (List 2)

<img width="905" alt="aps_75" src="https://user-images.githubusercontent.com/86648892/187022183-9bb4da5f-d767-4ea9-afe4-d201d08faf2f.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N, K = map(int, input().split()) # N 원소의 길이 # K 찾아야 될 숫자

    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] # 주어진 배열
    ans = 0

    for bit in range(1<<12): # 모든 부분집합의 경우의 수를 나타내는 bit 생성
        sm = 0 # 합
        cnt = 0 # 비트상 1로 표시되는 개수 (부분집합의 원소의 개수)
        # 합 구해놓기
        for i in range(0, 12):
            if (bit>>i) & 1:
                sm += arr[i]
        # 원소 개수 판별
        # bit가 0이 될때까지 끝의 자리 판별하고, 왼쪽으로 shift 후 다시 끝의 자리 판별 반복
        while bit:
            cnt += bit & 1
            bit = bit >> 1
        # 조건 만족 여부
        if cnt == N and sm == K:
            ans += 1
    print(f'#{test_case} {ans}')

'''
# 풀이
# 1) 굳이 while을 넣어줄 필요가 없었다 # (bit>>i) & 1이 True일 때 어차피 원소가 있는 것이므로 그 때 cnt += 1 해주면 됨
# 2) [1, 2, 3, 4, ... , 12]라고 선언하는 것보다 list comprehension을 활용하자
# 3) if sm==k and cnt==N과 같이 and 조건을 쓸 때는 확률이 희박한 것부터 앞에 써주는 것이 효율에 좋다 (short circuit)

T = int(input())
for test_case in range(1, T + 1):
    N, K = map(int, input().split())
    M = 12
    lst = [i for i in range(1, M+1)]
    ans = 0
    for bits in range(1, 1<<M):
        sm = cnt = 0
        for i in range(M):
            if (bits>>i) & 1 == 1:
                sm += lst[i]
                cnt += 1
        if sm==K and cnt==N:
            ans += 1
    print(f'#{test_case} {ans}')
'''
```

---

## 코딩반 이진탐색 (List 2)

<img width="912" alt="aps_76" src="https://user-images.githubusercontent.com/86648892/187022396-bb403737-51e2-4d4c-bb95-e2c3a1a6f7e8.png">

<img width="911" alt="aps_77" src="https://user-images.githubusercontent.com/86648892/187022402-16e30a96-181e-47d1-b533-99e04e0b4cc4.png">

```python
def bin_search(s, e, d):
    cnt = 0
    while s<=e:
        cnt += 1
        m = (s+e)//2
        if m == d: # 찾는 데이터 발견
            return cnt
        elif m < d: # 찾는데이터가 오른쪽(더 큰쪽)
            s = m
        else: # 왼쪽 탐색
            e = m
    return -1 # 이 문제에서는 이 코드 실행되지 않음

T = int(input())
for test_case in range(1, T + 1):
    P, A, B = map(int, input().split())

    a_cnt = bin_search(1, P, A)
    b_cnt = bin_search(1, P, B)

    if a_cnt<b_cnt:
        ans = 'A'
    elif a_cnt>b_cnt:
        ans = 'B'
    else:
        ans = '0'
    print(f'#{test_case} {ans}')

# 나의 풀이

'''
T = int(input())
for test_case in range(1, T+1):
    # 페이지 수이므로 정렬은 항상 되어있는 상태로 가정
    P, Pa, Pb = map(int, input().split())
    arr = [i for i in range(1, P+1)]
    s_idx = 0
    e_idx = P-1
    cnt1 = 0 # A 검색 횟수
    cnt2 = 0 # B 검색 횟수
    ans = 0 # 출력 값
    # 페이지를 못 찾는 경우는 없을 것
    # A
    while s_idx <= e_idx:
        cnt1 += 1
        m_idx = (s_idx+e_idx) // 2
        if arr[m_idx] == Pa:
            break
        elif arr[m_idx] > Pa:
            e_idx = m_idx
        else:
            s_idx = m_idx
    # B (s_idx와 e_idx 다시 초기화해줄 것)
    s_idx = 0
    e_idx = P-1
    while s_idx <= e_idx:
        cnt2 += 1
        m_idx = (s_idx+e_idx) // 2
        if arr[m_idx] == Pb:
            break
        elif arr[m_idx] > Pb:
            e_idx = m_idx
        else:
            s_idx = m_idx
    # A B 비교
    if cnt1 < cnt2:
        ans = 'A'
    elif cnt2 < cnt1:
        ans = 'B'
    
    print(f'#{test_case} {ans}')
'''
```

---

## 특별한 정렬 (List 2)

<img width="905" alt="aps_78" src="https://user-images.githubusercontent.com/86648892/187022531-7f95f76c-6fb9-48dd-a71c-5525d43268f7.png">

<img width="909" alt="aps_79" src="https://user-images.githubusercontent.com/86648892/187022533-c0a7be93-8303-4be0-846f-7c7c2d57af4c.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    arr = list(map(int, input().split()))
    ans = [0]*10 # 10개까지만 출력
    # selection sort 내림차순 정렬
    for i in range(N-1):
        maxIdx = i
        for j in range(i+1, N):
            if arr[maxIdx] < arr[j]:
                maxIdx = j
        arr[i], arr[maxIdx] = arr[maxIdx], arr[i]

    # 인덱스를 (0, 1), (2, 3), ...와 같이 쌍을 지어
    # 2로 나눈 몫만큼
    # 인덱스가 짝수라면 앞에서(큰 값부터), 인덱스가 홀수라면 뒤에서(작은 값부터) 가져와 배치
    for i in range(10): # 10개까지만 출력
        if i % 2 == 0:
            ans[i] = arr[i//2]
        else:
            ans[i] = arr[N-1-(i//2)]
    print(f'#{test_case}', end = ' ')
    print(*ans)

'''
T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    lst = list(map(int, input().split()))

    # [1] 오름차순 정렬
    # bubble sort
    for i in range(N-1, 0, -1):
        for j in range(i):
            if lst[j]>lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]

    sols = []
    for i in range(5):
        sols.append(lst[-1-i])
        sols.append(lst[i])

    print(f'#{test_case}', *sols)
'''

'''
# 만약 주어지는 정렬이 너무나도 길고 크다면?
# 전부 정렬하는 것은 무식한 것일 수 있음
# 그러므로 필요한 부분만 사용하는 방법을 알아보자

T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    lst = list(map(int, input().split()))

    # [0] 전체를 정렬하지 않고, 5번만 찾기
    for i in range(0, 10, 2):
        # i ~ 끝 중에서 가장 큰/작은값 index 찾기
        i_min = i_max = i
        for j in range(i, N):
            if lst[i_min]>lst[j]:   i_min=j
            if lst[i_max]<lst[j]:   i_max=j

        lst[i_max], lst[i] = lst[i], lst[i_max]
        if i_min == i: # i_min 가리키고 있던 값 이동
            i_min = i_max
        lst[i_min], lst[i+1] = lst[i+1], lst[i_min]

    print(f'#{test_case}', *lst[:10])

    # # [1] 오름차순 정렬
    # for i in range(N-1, 0, -1):
    #     for j in range(i):
    #         if lst[j]>lst[j+1]:
    #             lst[j], lst[j+1] = lst[j+1], lst[j]
    #
    # sols = []
    # for i in range(5):
    #     sols.append(lst[-1-i])
    #     sols.append(lst[i])
    #
    # print(f'#{test_case}', *sols)
'''
```

---

## Ladder 1 (List 2)

<img width="917" alt="aps_80" src="https://user-images.githubusercontent.com/86648892/187022669-3884b53a-0707-4f02-963c-2e34127bd1de.png">

<img width="884" alt="aps_81" src="https://user-images.githubusercontent.com/86648892/187022672-a4284406-49db-4184-9cf9-d600bd938034.png">

<img width="964" alt="aps_82" src="https://user-images.githubusercontent.com/86648892/187022673-db66d302-e56c-4675-bd89-82a6ef9641fb.png">

<img width="929" alt="aps_83" src="https://user-images.githubusercontent.com/86648892/187022675-66ff032f-a41e-49cd-afc1-5e61b9f86161.png">

```python
T = int(input())
for test_case in range(1, T+1):
    # 세방향 탐색 시 index out of range를 방지하기 위해 양쪽에 0으로 벽 하나씩 세우기
    arr = [[0] + list(map(int, input().split())) + [0] for _ in range(100)]
    di = [-1, 0, 0] # 상 좌 우
    dj = [0, -1, 1]
    dr = 0 # 상 방향으로 초기화
    # 출발 인덱스 초기화
    ci = 99
    cj = 1
    # 출발점 찾기 (2가 적혀있는 곳)
    for i in range(1, 101):
        if arr[ci][i] == 2:
            cj = i
    # i가 0이 되는 순간 종료
    while ci > 0:
        ni = ci + di[dr]
        nj = cj + dj[dr]

        if dr == 0: # 위로 가는 중일 때
            if arr[ni][nj-1] == 1: # 왼쪽에 1이 있다면 방향 왼쪽으로
                ci = ni
                cj = nj
                dr = 1
            elif arr[ni][nj+1] == 1: # 오른쪽에 1이 있다면 방향 오른쪽으로
                ci = ni
                cj = nj
                dr = 2
            else: # 둘다 없다면 그대로 방향 위로
                ci = ni
                cj = nj
        elif dr == 1: # 왼쪽으로 가는 중일 때
            if arr[ni][nj-1] == 0: # 다음 왼쪽 칸이 0으로 막혀있다면 방향 위로
                ci = ni
                cj = nj
                dr = 0
            else: # 다음에도 갈 곳이 있다면 그대로 진행
                ci = ni
                cj = nj
        elif dr == 2: # 오른쪽으로 가는 중일 때
            if arr[ni][nj+1] == 0: # 다음 오른쪽 칸이 0으로 막혀있다면 방향 위로
                ci = ni
                cj = nj
                dr = 0
            else:
                ci = ni
                cj = nj
    # 벽을 깬 인덱스로 반환
    ans = cj - 1
    print(f'#{test_case} {ans}')

'''
# 1) 2를 찾아서 시작
# 2) 이동 법칙
# 2-1) 좌 / 우에 길이 있는 경우: 그 쪽 우선이동
# 2-2) else: 위쪽 이동
# 2-3) 지나온 지도를 0으로 표시
# 3) 이동
# 3-1) i가 0이 될 때 멈춤
# 3-2) index error 방지
# 3-2-1) j가 0보다 크고(왼쪽으로 갈 곳이 있고) 왼쪽에 길이 있다면: 왼쪽으로 이동 + 지나온 지도 0으로 표시
# 3-2-2) j가 99보다 작고(오른쪽으로 갈 곳이 있고) 오른쪽에 길이 있다면: 오른쪽으로 이동 + 지나온 지도 0으로 표시
# 3-3-3) 둘다 아니라면 위로 이동

T = 10
# T = int(input())
for test_case in range(1, T + 1):
    _ = int(input())
    N = 100
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 초기값 설정
    i, j = N-1, 0
    # [1] 목적지(출발지) arr[][] == 2
    for tj in range(N):
        if arr[i][tj]==2:
            j = tj;
            break

    while i>0:
        if j>0 and arr[i][j-1]==1:    #왼쪽에 이동가능한 길이 있음
            arr[i][j]=0
            j-=1
        elif j<99 and arr[i][j+1]==1:   # 오른쪽방향 이동가능 체크
            arr[i][j]=0
            j+=1
        else:
            i-=1

    print(f'#{test_case} {j}')
'''
```

---

## 이진탐색 연습 (List 2)

<img width="839" alt="aps_84" src="https://user-images.githubusercontent.com/86648892/187022791-de5a14c1-54ed-4032-8f42-ae03e4a3fa2c.png">

<img width="907" alt="aps_85" src="https://user-images.githubusercontent.com/86648892/187022793-51330416-e945-4b68-b2bc-ba957bb38f60.png">

```python
def bin_search(lst, s, e, d):
    while s <= e:                           # s, e가 같아질 때도 수행
        m = (s+e)//2                        # 중앙값 인덱스
        if lst[m] == d:                     # 찾고자 하는 값과 같다면
            return m+1                      # 찾는 위치는 인덱스 + 1
        elif lst[m] > d:                    # 찾고자 하는 값이 왼쪽에 있다면
            e = m-1                         # end index를 중앙에서 한 칸 왼쪽으로
        else:                               # 찾고자 하는 값이 오른쪽에 있다면
            s = m+1                         # start index를 중앙에서 한 칸 오른쪽으로
    return 0
T = int(input())
for test_case in range(1, T+1):
    N, D = map(int, input().split())        # N은 숫자 개수, M은 타겟 넘버
    lst = list(map(int, input().split()))   # 숫자 목록
    ans = bin_search(lst, 0, N-1, D)        # 끝 인덱스는 리스트 길이의 -1
    print(f'#{test_case} {ans}')
```

---

## 문자열 검색 (String)

<img width="904" alt="aps_86" src="https://user-images.githubusercontent.com/86648892/187022891-706f35d8-01b3-4d06-b1fb-c2a014d85862.png">

<img width="896" alt="aps_87" src="https://user-images.githubusercontent.com/86648892/187022893-d94f77f3-f920-4ca7-97d4-9c6fc0c51fbb.png">

```python
def cmp(src, N, tar, M, i):
        for j in range(M):          # 타겟의 각 글자 검사
            if src[i+j] != tar[j]:  # 전체 문자열에서 시작지점인 i에서 j만큼 간 부분과, 타겟 문자열에서 j만큼 간 부분 비교
                return 0            # 비교 중 다르다면 매칭하지 않는 것이므로 해당 시작지점 i에서는 불일치, 0 반환
        return 1                    # 순회가 끝날 동안 다른 부분이 없다면 1 반환
T = 10
for test_case in range(1, T+1):
    _ = int(input())
    tar = input()   # 타겟 문자열
    src = input()   # 전체 문자열
    N = len(src)
    M = len(tar)
    ans = 0
    for i in range(N-M+1):          # 타겟이 전체를 넘지 않는 범위, i는 시작지점
        if cmp(src, N, tar, M, i):  # 일치한다면
            ans += 1                # 일치 횟수 증가
    print(f'#{test_case} {ans}')
```

---

## GNS (String)

<img width="881" alt="aps_88" src="https://user-images.githubusercontent.com/86648892/187023033-8546bb09-5214-41f4-aa98-e4ca51d02ed9.png">

<img width="913" alt="aps_89" src="https://user-images.githubusercontent.com/86648892/187023037-b0529c7f-25b8-436b-a50f-08f78976ccb6.png">

```python
nums = [i for i in range(10)]
chars = ['ZRO', 'ONE', 'TWO', 'THR', 'FOR', 'FIV', 'SIX', 'SVN', 'EGT', 'NIN']

# 숫자 -> 문자 함수
def num_to_chars(n):
    for i in range(10):
        if nums[i] == n:
            return chars[i]
        else:
            continue

# 문자 -> 숫자 함수
def chars_to_num(s):
    for i in range(10):
        if chars[i] == s:
            return nums[i]
        else:
            continue

T = int(input())
for _ in range(T):
    case_num, case_len = input().split()
    ans = list(input().split())
    # 문자 -> 숫자
    for i in range(len(ans)):
        ans[i] = chars_to_num(ans[i])
    # 오름차순 sort
    for i in range(len(ans)-1):
        min_idx = i
        for j in range(i+1, len(ans)):
            if ans[min_idx] > ans[j]:
                min_idx = j
        ans[min_idx], ans[i] = ans[i], ans[min_idx]
    # 숫자 -> 문자
    for i in range(len(ans)):
        ans[i] = num_to_chars(ans[i])
    print(case_num)
    print(*ans)

'''
# sorting을 하면 c에서는 아마 시간초과가 날 것이다
# 1) 카운트 배열을 만들어주고
# 2) dictionary를 만들어, 이를 통해 카운트 배열에 해당 개수를 cnt에 추가
# 3) 카운트 개수만큼 ZRO, ONE, ...를 추가

# lookup table 생성
tbl = ['ZRO', 'ONE', 'TWO', 'THR', 'FOR', 'FIV', 'SIX', 'SVN', 'EGT', 'NIN']
# dictionary comprehension으로 딕셔너리 생성
dct = {tbl[n]: n for n in range(10)}

T = int(input())
for test_case in range(1, T+1):
    _, N = input().split()
    lst = list(input().split())

    # 카운트 배열 생성
    cnts = [0]*10
    for st in lst:
        cnts[dct[st]] += 1 # 해당 문자의 자리에 카운트 누적

    # 출력할 결과에 cnts 개수만큼 str 붙이기
    sols = []
    for i in range(10):
        sols.append((tbl[i]+' ') * cnts[i]) # 사이사이 공백이 있어야 하므로 공백 더해줌 # 룩업테이블의 해당 값을 해당 값의 카운트 배열 값 개수만큼 추가
    
    print(f'#{test_case}')
    print(*sols)
'''
```

---

## 간단한 소인수분해 (IM)

<img width="910" alt="aps_90" src="https://user-images.githubusercontent.com/86648892/187023106-0dd0d688-3cef-4fd2-88cd-48727b064cdf.png">

<img width="907" alt="aps_91" src="https://user-images.githubusercontent.com/86648892/187023108-e7ca505e-cfb1-4fc3-870d-83067697ce34.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    ans = [0] * 5
    divs = [2, 3, 5, 7, 11]
    while N > 1:
        for i in range(5):
            if N % divs[i] == 0:
                ans[i] += 1
                N = N / divs[i]
    print(f'#{test_case}', end = ' ')
    print(*ans)
    
'''
# print(f'#{test_case}', *ans) 로 표기 가능
# while N % divs[i] == 0으로 조건 주고
# N = N // divs[i]로 설정하는 방법도 있음
# divs는 밖으로 빼주자

divs = [2, 3, 5, 7, 11]

T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    cnts = [0]*5
    for i in range(5):
        while N % divs[i] == 0:
            cnts[i] += 1
            N //= divs[i]

    print(f'#{test_case}', *cnts)
'''
```

---

## 현주의 상자 바꾸기 (IM)

<img width="914" alt="aps_92" src="https://user-images.githubusercontent.com/86648892/187023163-285f1545-da3d-445c-844a-0bc2b01d321a.png">

<img width="897" alt="aps_93" src="https://user-images.githubusercontent.com/86648892/187023165-3bbc6962-6776-4dc2-b365-95aeca6e7152.png">

```python
# start, end 인덱스 활용
T = int(input())
for test_case in range(1, T+1):
    N, Q = map(int, input().split())        # N 상자의 개수, Q 작업 횟수
    ans = [0]*N                             # 상자들 0으로 초기화

    for i in range(1, Q+1):                 # 1부터 Q까지의 숫자로 작업
        s, e = map(int, input().split())    # 작업할 부분 인덱스
        for j in range(s-1, e):             # 해당 부분에 작업
            ans[j] = i
    print(f'#{test_case}', *ans)
```

---

## 삼성시의 버스 노선 (IM)

<img width="904" alt="aps_94" src="https://user-images.githubusercontent.com/86648892/187023219-032a2ece-5273-4ef9-b855-02c3b5cf9e7b.png">

<img width="925" alt="aps_95" src="https://user-images.githubusercontent.com/86648892/187023224-235dd07c-a46f-4e06-9e17-16acdcb7fbc1.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input()) # 버스의 수
    bus = [list(map(int, input().split())) for _ in range(N)]
    P = int(input()) # 정류장의 수
    station = [int(input()) for _ in range(P)]
    cnts = [0] * (P+1)

    for i in range(N):
        start, end = bus[i][0], bus[i][1]
        for j in range(start, end+1):
            cnts[j] += 1

    print(f'#{test_case}', *cnts[1:])

'''
T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    cnts = [0]*5001
    for _ in range(N):
        S, E = map(int, input().split())
        for i in range(S, E+1):
            cnts[i] += 1

    sols = []
    P = int(input())
    for _ in range(P):
        n = int(input())
        sols.append(cnts[n])

    print(f'#{test_case}', *sols)
'''
```

---

## 파리 퇴치 (IM)

<img width="976" alt="aps_96" src="https://user-images.githubusercontent.com/86648892/187023309-20c9ed43-e547-4662-a596-aedcbdd57963.png">

<img width="921" alt="aps_97" src="https://user-images.githubusercontent.com/86648892/187023313-a6a9d24a-68c5-436a-976b-d2c85fcd5ec6.png">

<img width="918" alt="aps_98" src="https://user-images.githubusercontent.com/86648892/187023314-54fafc79-75c8-43c6-ace5-f805ab2484ec.png">

```python
# 이 문제는 파리퇴치이지만 네방향 탐색은 아님 (di, dj로 접근 x)
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    ans = 0

    for si in range(N):             # 모든 출발점 탐색
        for sj in range(N):
            cnt = 0                 # 아래 for문 순회에서 ni = si + 0, nj = sj + 0인 경우도 포함(즉, 시작점 파리수도 더해지므로 cnt는 0으로 초기화)
            for i in range(M):      # 출발점을 기준으로 길이 M만큼의 2차원 리스트 범위 탐색
                for j in range(M):
                    ni = si + i     # 이동
                    nj = sj + j
                    if 0 <= ni < N and 0 <= nj < N:     # 범위 안이라면
                        cnt += arr[ni][nj]              # 파리 퇴치 수 추가
            if ans < cnt:           # 최대 cnt로 ans 업데이트
                ans = cnt

    print(f'#{test_case} {ans}')

# 교수님 풀이
# 1) 나는 if 0 <= ni < N and 0 <= nj < N을 조건으로 넣은데 반해, 교수님은 애초에 si, sj에 대한 가능한 범위를 range(N-M+1)로 설정
# 2) 나는 ni = si + i, nj = sj + j로 설정한 반면, 교수님은 si와 sj 좌표를 기준으로 range(si, si+M), range(sj, sj+M)으로 설정하여 접근
'''
T = int(input())
for test_case in range(1, T + 1):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    mx = 0
    for si in range(N-M+1):
        for sj in range(N-M+1): # si, sj 좌표 기준으로
            sm = 0
            for i in range(si, si+M):
                for j in range(sj, sj+M):
                    sm += arr[i][j]
            if mx < sm:
                mx = sm

    print(f'#{test_case} {mx}')
'''
```

---

## 어디에 단어가 들어갈 수 있을까 (IM)

<img width="1040" alt="aps_99" src="https://user-images.githubusercontent.com/86648892/187023374-5b7b611b-db58-4aa2-b0a9-b4e83a35874b.png">

<img width="939" alt="aps_100" src="https://user-images.githubusercontent.com/86648892/187023378-5ac9e0c9-c0fe-4a3e-95cc-0579a373d75a.png">

<img width="951" alt="aps_101" src="https://user-images.githubusercontent.com/86648892/187023379-eb67d2bd-0875-4a0a-8e90-2f6124765c5f.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N, K = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    cnt = 0     # 해당 열이나 행에서 현재 누적 칸 길이 수
    ans = 0     # 단어와 같은 길이의 칸 수
    # 1) 1이 나온다면 cnt를 추가해준다
    # 2) 0이 나오는 경우 그 시점 cnt(칸 길이)가 K와 일치하면 ans에 1을 추가해주고 cnt(칸 길이)를 0으로 초기화
    # 3) 다만 끝자리에 1이 나오는 경우 해당 행이나 열이 끝나는 것이기에 누적 cnt를 확인해주고, cnt를 0으로 초기화하는 작업을 해줘야함
    for i in range(N):
        # 가로 검사
        for j in range(N):
            if arr[i][j] == 1 and j == N-1: # 3)
                if cnt == K-1:              # 해당 1을 포함한 길이가 K가 되어야 하므로 이전까지 누적 cnt는 K-1
                    ans += 1
                cnt = 0
            elif arr[i][j] == 1:            # 2)
                cnt += 1
            else:
                if cnt == K:                # 1)
                    ans += 1
                cnt = 0
        cnt = 0                             # 행이나 열이 끝날 때마다 cnt는 0으로 초기화
        # 세로 검사
        for j in range(N):
            if arr[j][i] == 1 and j == N-1:
                if cnt == K-1:
                    ans += 1
                cnt = 0
            elif arr[j][i] == 1:
                cnt += 1
            else:
                if cnt == K:
                    ans += 1
                cnt = 0
    print(f'#{test_case} {ans}')

# 교수님 풀이
# 1) 나는 맨 오른쪽에 1이 오는 경우 cnt값이 추가되지 않는 경우를 방지하기 위해 if 조건을 하나 더 걸어준 반면, 교수님은 0으로 padding하는 방법 선택
# 2) 나는 arr[i][j], arr[j][i]를 통해 가로, 세로 검사를 진행한 것에 반해 교수님은 zip을 사용
'''
T = int(input())
for test_case in range(1, T + 1):
    N, K = map(int, input().split())
    arr = [list(map(int, input().split())) + [0] for _ in range(N)] + [[0]*(N+1)]
    ans = 0
    for _ in range(2):
        for i in range(N+1):
            cnt = 0
            for j in range(N+1):
                if arr[i][j]==1:
                    cnt += 1
                else:
                    if cnt == K:
                        ans += 1
                    cnt = 0
        arr = list(zip(*arr))

    print(f'#{test_case} {ans}')
'''
```

---

## 스도쿠 검증 (IM)

<img width="936" alt="aps_102" src="https://user-images.githubusercontent.com/86648892/187023472-cf87681a-5e8c-4523-976f-a68213303c8f.png">

<img width="923" alt="aps_103" src="https://user-images.githubusercontent.com/86648892/187023475-99b0c19f-9a5b-4294-a7db-37e8e7963363.png">

<img width="935" alt="aps_104" src="https://user-images.githubusercontent.com/86648892/187023476-16fd4093-5216-42d3-8721-d8820a09b26d.png">

```python
T = int(input())
for test_case in range(1, T+1):
    arr = [list(map(int, input().split())) for _ in range(9)]   #sudoku
    cnt = [0]*9 # n-1에 해당하는 인덱스에 카운트를 표시
    ans = 1
    si = sj = 0

    # 가로 검사
    for lst in arr:
        for i in range(9):
            cnt[lst[i]-1] += 1
        if 2 in cnt:                    # cnt에 2가 있다는 것은 곧 중복된 것이 있다는 의미
            ans = 0
            break                       # 해당 행 검사 종료
        else:
            cnt = [0]*9                 # 한 행 검사 후 cnt 초기화

    # 세로 검사
    for i in range(9):
        for lst in arr:
            cnt[lst[i]-1] += 1
        if 2 in cnt:
            ans = 0
            break                       # 해당 열 검사 종료
        else:
            cnt = [0]*9                 # 한 열 검사 후 cnt 초기화

    # 3x3 검사
    for si in range(0, 9, 3):           # si, sj는 각각 0, 3, 6에서 시작
        for sj in range(0, 9, 3):
            for i in range(si, si+3):   # 각 si, sj에 대해 3칸씩 검사
                for j in range(sj, sj+3):
                    cnt[arr[i][j]-1] += 1
            if 2 in cnt:
                ans = 0
                break                   # 해당 박스 검사 종료
            else:
                cnt = [0]*9             # 한 박스 검사 후 cnt 초기화
    
    print(f'#{test_case} {ans}')

# 교수님 풀이
# 1) 나는 카운트 배열을 만들어 2가 있냐 없냐로 판단했다면, 교수님은 check 리스트를 만들고, not in 연산자 활용
# 2) 함수로 묶어줌
# 3) range(0, 9, 3)과 같이 step 활용하는 것 기억!!
'''
def solve():
    for i in range(N):  # 행 체크
        chk = []
        for j in range(N):
            if arr[i][j] not in chk:    # chk[] 없는 경우: 추가
                chk.append(arr[i][j])
            else:                       # 이미 있는경우: 실패
                return 0

    for j in range(N):  # 열 체크
        chk = []
        for i in range(N):
            if arr[i][j] not in chk:    # chk[] 없는 경우: 추가
                chk.append(arr[i][j])
            else:                       # 이미 있는경우: 실패
                return 0

    for si in range(0, 9, 3):
        for sj in range(0, 9, 3):
            chk = []
            for i in range(si, si+3):
                for j in range(sj, sj+3):
                    if arr[i][j] not in chk:  # chk[] 없는 경우: 추가
                        chk.append(arr[i][j])
                    else:  # 이미 있는경우: 실패
                        return 0
    return 1

# T = 3
T = int(input())
for test_case in range(1, T + 1):
    N = 9
    arr = [list(map(int, input().split())) for _ in range(N)]

    ans = solve()

    print(f'#{test_case} {ans}')
'''
```

---

## 자기 방으로 돌아가기 (IM)

<img width="937" alt="aps_105" src="https://user-images.githubusercontent.com/86648892/187023544-7282df58-6a7e-4595-bb80-af9f3ebdd812.png">

<img width="918" alt="aps_106" src="https://user-images.githubusercontent.com/86648892/187023551-84f576c3-90c8-4d3d-8c22-b39d74f8491d.png">

```python
# (1, 2), (3, 4), ... 가 복도 내에서 같은 칸을 사용
# room (1, 2)는 복도의 index 0, room(3, 4)는 복도의 index 2 ... 각 수가 해당 인덱스로 배당되려면 (N-1) // 2
# 가운데 복도를 카운트 배열로 생성하여 복도 칸 중 가장 많이 지나가진 카운트 수만큼 동선이 겹칠 것이므로 카운트 배열의 최댓값이 답
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    cnts = [0]*200      # 복도 (학생이 지나간 수 카운트 배열)
    ans = 0             # 필요 단위 시간

    for _ in range(N):  # 학생 수 만큼 실행
        s, e = map(int, input().split())        # 시작점 도착점
        if s > e:                               # 시작점이 더 오른쪽에 있을 시 카운트에 추가안되는 것을 방지
            s, e = e, s
        for i in range((s-1)//2, ((e-1)//2)+1): # 방 번호 s, e가 카운트 배열에서 가리키는 인덱스 값은 (N-1) // 2
            cnts[i] += 1                        # 시작부터 도착방까지 가는동안 지나는 복도에 카운트 1 추가

    for n in cnts:                              # cnts 중 최대값 구하기
        if ans < n:
            ans = n

    print(f'#{test_case} {ans}')
```

---

## 파리 퇴치 3 (IM)

<img width="928" alt="aps_107" src="https://user-images.githubusercontent.com/86648892/187023622-9c9a6744-952d-4090-a806-eefde5f5f781.png">

<img width="923" alt="aps_108" src="https://user-images.githubusercontent.com/86648892/187023626-dcf65264-6c11-40cb-b34a-39097343f174.png">

```python
di1 = [0, 1, 0, -1]     # 우 하 좌 상
dj1 = [1, 0, -1, 0]
di2 = [-1, 1, 1, -1]    # 우상 우하 좌하 좌상 (대각선)
dj2 = [1, 1, -1, -1]
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())    # N은 사각형 크기, M은 스프레이 범위
    arr = [list(map(int, input().split())) for _ in range(N)]
    ans = 0                             # 최대 파리퇴치 수
    # 모든 출발점에 대하여 검사
    # 십자가 모양
    for si in range(N):
        for sj in range(N):
            cnt = arr[si][sj]           # 시작좌표가 바뀔 때 시작지점 파리퇴치 가능 수 초기화
            for mul in range(1, M):     # 스프레이 범위만큼 검사
                for n in range(4):      # 우 하 좌 상 (mul만큼 이동)
                    ni = si + di1[n]*mul
                    nj = sj + dj1[n]*mul
                    if 0 <= ni < N and 0 <= nj < N:     # 다음 이동 좌표가 범위 내라면
                        cnt += arr[ni][nj]
            if ans < cnt:               # 가장 큰 cnt라면 ans 업데이트
                ans = cnt
    # X 모양
    for si in range(N):
        for sj in range(N):
            cnt = arr[si][sj]           # 시작좌표가 바뀔 때 시작지점 파리퇴치 가능 수 초기화
            for mul in range(1, M):     # 스프레이 범위만큼 검사
                for n in range(4):      # 우상 우하 좌하 좌상 (mul만큼 이동)
                    ni = si + di2[n]*mul
                    nj = sj + dj2[n]*mul
                    if 0 <= ni < N and 0 <= nj < N:     # 다음 이동 좌표가 범위 내라면
                        cnt += arr[ni][nj]
            if ans < cnt:               # 가장 큰 cnt라면 ans 업데이트
                ans = cnt
    print(f'#{test_case} {ans}')

# 교수님 풀이
# di, dj를 따로 리스트로 만들지 않고 for문에 튜플 쌍을 넣어서 풀이
'''
T = int(input())
for test_case in range(1, T + 1):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    ans = 0

    # 십자가 모양 기준
    for si in range(N):
        for sj in range(N): # 기준좌표 si, sj

            cnt = arr[si][sj] # 기준점 기준 파리 개수
            for mul in range(1, M):
                for di,dj in ((-1,0),(1,0),(0,-1),(0,1)):
                    ni,nj = si+di*mul, sj+dj*mul
                    if 0<=ni<N and 0<=nj<N:
                        cnt += arr[ni][nj]
            if ans<cnt:
                ans = cnt

    # X 모양 기준
    for si in range(N):
        for sj in range(N):  # 기준좌표 si, sj

            cnt = arr[si][sj]
            for mul in range(1, M):
                for di, dj in ((-1,-1), (-1, 1), (1, -1), (1, 1)):
                    ni, nj = si + di * mul, sj + dj * mul
                    if 0 <= ni < N and 0 <= nj < N:
                        cnt += arr[ni][nj]
            if ans < cnt:
                ans = cnt

    print(f'#{test_case} {ans}')
'''
```

---

## 회문 2 (String)

<img width="898" alt="aps_109" src="https://user-images.githubusercontent.com/86648892/187023791-b5dbed54-ced9-440b-9292-8966a731980d.png">

<img width="914" alt="aps_110" src="https://user-images.githubusercontent.com/86648892/187023792-632c8e48-825f-4f87-8e44-b340fcc8fb5d.png">

<img width="915" alt="aps_111" src="https://user-images.githubusercontent.com/86648892/187023794-9518141f-5fec-4035-893d-49cee2b3ff89.png">

```python
# maxLen을 반환
# 아래풀이와 비교해 시간 단축
# 2,591 ms
# 여기서 더 시간 단축하는 것은 4번 풀이 참고

def palindrome_max_length(N, arr):
    maxLen = 1
    for i in range(N):  # 각 행에 대하여
        for j in range(N, maxLen, -1):  # 회문길이를 최댓값부터 줘서 거꾸로 검사 # 여기서 maxLen은 범위 넣을 때 정해지니 1로 고정 # N에서 2까지 갈 때 회문이 없으면 어차피 maxLen은 1로 유지됨
            if maxLen > j: # 밑에서 회문을 찾아 maxLen이 업데이트되었다면 그 아래 j는 검사하지 않음(break) <-- 이를 통해 시간 단축
                break
            for k in range(N-j+1):  # 해당 행에서 한 칸씩 이동하면서 회문여부 검사
                test_arr = arr[i][k:k+j]
                if test_arr == test_arr[::-1]:  # 회문이라면 maxLen을 업데이트
                    if len(test_arr) > maxLen:
                        maxLen = len(test_arr)
    return maxLen

T = 10
for _ in range (1, T+1):
    N = 100
    test_case = input()
    rows = [list(input()) for _ in range(N)]
    cols = list(map(list, zip(*rows)))
    maxLen = 1

    row_max = palindrome_max_length(N, rows)
    col_max = palindrome_max_length(N, cols)

    if row_max >= col_max:
        maxLen = row_max
    else:
        maxLen = col_max

    print(f'#{test_case} {maxLen}')

# 1

'''
# rows와 cols를 만들고 -> 회문길이 1~100에 대하여 회문인지를 판별하고 -> 회문이라면 해당 lengths에 해당 회문의 길이를 추가
# 이후 lengths에서 최대 길이를 구함

#회문의 각 length들을 가지고 있는 배열 반환
def palindrome_length(N, rows):
    lengths = []
    cols = list(map(list, zip(*rows))) # 전치 행렬

    for i in range(N): # 각 행과 열에 대해
        for j in range(N, 0, -1): # 회문 길이 1~100
            for k in range(N-j+1): # 각 행과 열에 있는 회문 길이 lengths에 추가
                row_arr = rows[i][k:k+j]
                col_arr = cols[i][k:k+j]
                if row_arr == row_arr[::-1]:
                    lengths.append(j)
                if col_arr == col_arr[::-1]:
                    lengths.append(j)
    return lengths

T = 10
for _ in range (1, T+1):
    N = 100
    test_case = input()
    rows = [list(input()) for _ in range(N)]
    maxIdx = 0 # 최대 길이 index
    maxLen = 1 # maxIdx의 길이

    # 회문들
    lengths = palindrome_length(N, rows)

    # 각 회문의 길이 비교 및 최대 길이 구하기
    for i in range(len(lengths)):
        if lengths[i] > lengths[maxIdx]:
            maxIdx = i
    maxLen = lengths[maxIdx]

    print(f'#{test_case} {maxLen}')
'''

# 2

'''
# rows와 cols를 만들고 -> 회문길이 1~100에 대하여 회문인지를 판별하고
# 회문이라면 rows의 경우 maxLen1(가로행에서의 회문 중 최대길이)와 비교하여 더 긴 회문이라면 해당 길이를 최댓값으로 업데이트
# cols의 회문 중 가장 긴 길이를 마찬가지로 maxLen2로 업데이트
# maxLen1(가로행 회문 길이 중 최대)과 maxLen2(세로열 회문 길이 중 최대)을 비교하여 최종적으로 가장 큰 길이 반환

def palindrome_max_length(N, rows):
    maxLen1, maxLen2 = 1, 1
    cols = list(map(list, zip(*rows))) # 전치 행렬

    for i in range(N): # 각 행과 열에 대해
        for j in range(N, 0, -1): # 회문 길이 1~100
            for k in range(N-j+1): # 각 행과 열에 있는 회문 길이 lengths에 추가
                row_arr = rows[i][k:k+j]
                col_arr = cols[i][k:k+j]
                if row_arr == row_arr[::-1]:
                    if len(row_arr) > maxLen1:
                        maxLen1 = len(row_arr)
                if col_arr == col_arr[::-1]:
                    if len(col_arr) > maxLen2:
                        maxLen2 = len(col_arr)
    if maxLen1 >= maxLen2:
        return maxLen1
    else:
        return maxLen2

T = 10
for _ in range (1, T+1):
    N = 100
    test_case = input()
    rows = [list(input()) for _ in range(N)]

    maxLen = palindrome_max_length(N, rows)

    print(f'#{test_case} {maxLen}')
'''

# 3 (교수님 풀이) 2,690 ms

'''
def solve():
    for leng in range(N, 1, -1):    # 길이 N부터 1씩 줄이면서 확인
        for lst in arr1:
            for i in range(N-leng+1):   # 시작위치
                if lst[i:i+leng] == lst[i:i+leng][::-1]:
                    return leng

        for lst in arr2:
            for i in range(N-leng+1):   # 시작위치
                if lst[i:i+leng] == lst[i:i+leng][::-1]:
                    return leng
    return leng

T = 10
# T = int(input())
for test_case in range(1, T + 1):
    _ = input()
    N = 100
    arr1 = [input() for _ in range(N)]
    arr2 = list(zip(*arr1))

    ans = solve()

    print(f'#{test_case} {ans}')
'''

# 4 (속도가 개선된 코드) 519 ms
# 기존 아이디어: 회문 리스트를 거꾸로 뒤집어 전부 비교
# 새로운 아이디어: 회문 리스트를 N // 2 만큼 반으로 잘라 좌우를 비교

'''
# 대칭 여부 파악
def is_sym(arr, length):
    for lst in arr:
        for i in range(N-length+1):     # 시작위치
            for j in range(length//2):  # 절반만 검사
                if lst[i+j] != lst[i+length-1-j]:   # 양쪽이 대칭이 아니라면
                    break
            else: # 절반을 순회하는 동안 break를 안했다는 것은 대칭이라는 것
                return True
    return False

T = 10
for test_case in range(1, T+1):
    _ = input()
    N = 100
    rows = [input() for _ in range(N)]
    cols = list(zip(*rows))

    for ans in range(N, 1, -1): # 회문 길이를 100부터 검사
        if is_sym(rows, ans) or is_sym(cols, ans):  # 가로나 세로에서 회문이 나온다면
            break   # 그 즉시 순회를 멈추고
    
    # ans에는 순회를 멈춘 순간의 회문 길이(최대값)가 들어가 있을 것임
    print(f'#{test_case} {ans}')
'''
```

---

## 문자열 비교 (String)

<img width="930" alt="aps_112" src="https://user-images.githubusercontent.com/86648892/187024014-e2e83a95-5faa-42a2-9560-6f57209f0cfa.png">

<img width="915" alt="aps_113" src="https://user-images.githubusercontent.com/86648892/187024016-778e775d-c4e2-40b8-8c08-017375ebab79.png">

```python
def match(p, t):
    i = 0 # 전체 문자열 t의 인덱스
    j = 0 # 안에 속할 문자열 p의 인덱스
    while j < len(p) and i < len(t):
        if t[i] != p[j]: # 만약 일치에 실패한다면
            i = i-j # i는 j와 비교를 시작한 부분에서 한 칸 더 오른쪽으로 시작점을 옮김
            j = -1 # j는 처음부터 (인덱스 0부터) 비교 시작
        i = i+1
        j = j+1
    # 1 일치한다면 j가 len(p)까지 상승하여 (j의 끝까지 일치확인)
    # 2 일치하지 않는다면 결국 i가 len(t)까지 상승하여
    # while문이 종료될 것
    # 1의 경우
    if j == len(p):
        return 1
    # 2의 경우
    else:
        return 0

T = int(input())
for test_case in range(1, T+1):
    p = input()
    t = input()
    ans = match(p, t)
    print(f'#{test_case} {ans}')
```

---

## 회문 (String)

<img width="903" alt="aps_114" src="https://user-images.githubusercontent.com/86648892/187024127-f86ee1d8-26b1-46dd-b6c2-dab0fbd476bc.png">

<img width="909" alt="aps_115" src="https://user-images.githubusercontent.com/86648892/187024130-b1c810e7-65f0-49c8-9eb3-f8ddc92dd89f.png">

<img width="914" alt="aps_116" src="https://user-images.githubusercontent.com/86648892/187024133-b0ef44dc-97a3-4c71-8763-81fe7585d776.png">

```python
# N*N 크기 글자판에서 길이가 M인 회문 찾기
def palindrome(N, M, rows):
    # 행 탐색
    for i in range(N):
        for j in range(N-M+1):
            if rows[i][j:j+M] == rows[i][j:j+M][::-1]:
                return ''.join(rows[i][j:j+M]) # array를 join 메서드를 통해 문자열로 변환
    # 열 탐색
    cols = list(map(list, zip(*rows))) # zip을 통해 전치 행렬을 만드는 법
    for i in range(N):
        for j in range(N-M+1):
            if cols[i][j:j+M] == cols[i][j:j+M][::-1]: # 슬라이싱을 통해 역순이 같은지 확인
                return ''.join(cols[i][j:j+M])

T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())
    rows = [list(input()) for _ in range(N)]
    ans = palindrome(N, M, rows)
    print(f'#{test_case} {ans}')
```

---

## 글자수 (String)

<img width="912" alt="aps_117" src="https://user-images.githubusercontent.com/86648892/187024202-a5637ea2-e099-417f-8132-1dd768463a25.png">

```python
T = int(input())
for test_case in range(1, T+1):
    str1 = input()
    str2 = input()
    # str1 기준 lookup table 생성
    tbl = []
    for i in str1:
        if i in tbl:
            continue
        else:
            tbl.append(i)
    # dictionary 생성 (카운트 배열 인덱스용)
    dct = {tbl[n]: n for n in range(len(tbl))}
    # 카운트 배열 생성
    cnts = [0]*len(tbl)
    # str2를 순회하여 포함되는 카운트 누적
    for i in str2:
        if i in tbl:
            cnts[dct[i]] += 1
    # 최대 카운트 도출
    ans = 0
    for i in range(len(cnts)):
        if ans < cnts[i]:
            ans = cnts[i]
    print(f'#{test_case} {ans}')
```

---

## 가장 빠른 문자열 타이핑 (String)

<img width="907" alt="aps_118" src="https://user-images.githubusercontent.com/86648892/187024274-a34f0f62-2993-430e-9176-075fdbfd6d66.png">

<img width="908" alt="aps_119" src="https://user-images.githubusercontent.com/86648892/187024280-4806c359-3247-4707-886a-d74d4a63dcb6.png">

```python
T = int(input())
for test_case in range(1, T+1):
    src, tar = input().split() # source 문자열과 target 문자열
    N, M = len(src), len(tar)
    i = 0 # src에서 탐색할 출발점 인덱스 초기화
    ans = 0

    # src에서 탐색할 출발 인덱스이므로 len(src)보다 작아야함
    while i < N:
        if src[i:i+M] == tar: # 해당 출발지점에서 target과 매칭한 결과 매칭한다면
            i += M # 다음 탐색 때 겹치는 부분이 없도록 출발점을 target의 길이만큼 이동
        else:
            i += 1 # 매칭이 되지 않는다면 brute force 방식으로 1만큼 이동
        ans += 1 # 매칭하면 M만큼, 매칭하지 않는다면 1만큼 움직이고, 움직일 때마다 타이핑 1회와 마찬가지이므로 ans += 1
    
    print(f'#{test_case} {ans}')
```

---

## 괄호검사 (Stack 1)

<img width="906" alt="aps_120" src="https://user-images.githubusercontent.com/86648892/187024344-a85d6345-48db-46d8-a650-90b091328e62.png">

```python
T = int(input())
for test_case in range(1, T + 1):
    st = input()
    stk = []
    ans = 1
    for ch in st:
        if ch == '(':       # '('인 경우 스택에 push
            stk.append(ch)
        else:   # 현재는 ')'인 경우 pop
            if stk:         # pop할때는 반드시 스택 empty확인
                stk.pop()
            else:
                ans = 0 # 수식오류 [1] : '(' 짝이 없는데 ')'이 닫힌 경우
                break
    if stk:
        ans = 0 # 수식오류 [2] : 모든 기호 처리 종료후 스택에 push한 데이터가 남은 경우

    print(f'#{test_case} {ans}')

'''
나의 풀이

T = int(input())
for test_case in range(1, T+1):
    arr = list(input())
    stackSize = len(arr)
    stack = [0]*stackSize
    top = -1
    ans = 0
    cnt1 = 0                                    # '('의 개수
    cnt2 = 0                                    # ')'의 개수

    for i in arr:                               # 괄호 각각의 개수 구하기
        if i == '(':
            cnt1 += 1
        elif i == ')':
            cnt2 += 1

    for i in range(len(arr)):
        if arr[i] == '(':                       # push
            top += 1
            stack[top] = arr[i]
        elif arr[i] == ')' and i == 0:          # 맨 처음에 ')'인 경우 pop 불가
            ans = 0
            break
        elif arr[i] == ')' and stack[top] == 0: # '('가 없는 경우 ')' pop 불가
            ans = 0
            break
        elif arr[i] == ')':
            stack[top] = 0
            top -= 1

    if cnt1 == cnt2:                            # pop 후 '('가 남아있다면 짝이 안맞는 것
        ans = 1
    else:
        ans = 0

    print(f'#{test_case} {ans}')
'''
```

---

## 깊이우선탐색 (Stack 1)

<img width="912" alt="aps_121" src="https://user-images.githubusercontent.com/86648892/187024477-468ad958-1752-411d-a730-57f8b0e04ca5.png">

<img width="906" alt="aps_122" src="https://user-images.githubusercontent.com/86648892/187024481-51f9fefc-9666-4f22-89b6-88c5277d76ee.png">

```python
# v는 시작지점 N은 정점개수+1 (1부터 노드번호가 있기에 인덱스 맞추기)
def dfs(v, N):
    ans = []
    top = -1            # stack top 초기화
    ans.append(v)            # 방문해서 할 일
    visited[v] = 1      # A~G 중 시작점 방문 표시
    while True:
        for w in adjList[v]:        # 시작점의 인접 정점 검사
            if visited[w] == 0:     # 아직 탐색하지 않은 곳이라면 탐색
                top += 1            # top 인덱스 추가
                stack[top] = v      # 이전 지점인 v를 스택에 모아놓음
                v = w               # 현재 위치를 w로 변경
                ans.append(v)            # 방문해서 할 일
                visited[w] = 1      # 탐색했으므로 1로 변경
                break
        else:
            if top != -1:           # 스택이 비어있지 않은 경우
                v = stack[top]      # pop
                top -= 1
            else:                   # 스택이 비어있으면
                break               # while 종료
    return ans

T = int(input())
for test_case in range(1, T+1):
    V, E = map(int, input().split())
    N = V+1

    # 인접원소 리스트 생성
    adjList = [[] for _ in range(N)]
    for _ in range(E):
        a, b = map(int, input().split())
        adjList[a].append(b)
        adjList[b].append(a)

    visited = [0]*N     # visited 생성
    stack = [0]*N       # stack 생성 (이전 탐색 지점)
    ans = dfs(1, N)
    print(f'#{test_case}', *ans)
```

---

## 파스칼의 삼각형 (Stack 1)

<img width="913" alt="aps_123" src="https://user-images.githubusercontent.com/86648892/187024542-d45f7243-d924-448d-b9f2-7bc59a33e8d7.png">

<img width="907" alt="aps_124" src="https://user-images.githubusercontent.com/86648892/187024543-1b2c5707-a672-4298-8575-4dedc96b20b3.png">

```python
# 1 반으로 나누고 stack을 사용하여 나머지 반을 채우는 방식

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    tri = [[0]*(n+1) for n in range(N)]     # 삼각형 배열 0으로 초기화
    stack = []      # 왼쪽과 대칭인 오른쪽 부분에 넣을 값을 stack으로 저장 (LIFO)
    for i in range(N):      # 삼각형의 각 행 접근
        if i == 0:          # 첫 행 1
            tri[i][0] = 1
        elif i == 1:        # 둘째 행 1 1
            tri[i][0] = 1
            tri[i][1] = 1
        else:
            # 각 행들 가운데 기준 왼쪽 값들
            # 홀수 개수일 경우 가운데 값 포함
            for j in range((i//2)+1):
                if j == 0:
                    tri[i][j] = 1               # 첫 값은 1로 고정
                    stack.append(tri[i][j])     # 오른쪽에 넣을 stack 값에 포함
                else:
                    tri[i][j] = tri[i-1][j-1] + tri[i-1][j]     # 가운데 기준 왼쪽 값들 구함
                    stack.append(tri[i][j])                     # stack에 포함

            # 각 행들 가운데 기준 오른쪽 값들
            # 홀수 개수일 경우 가운데 값에 스택에 있는 똑같은 값을 다시 넣음
            for k in range(((i//2)+(i%2)), len(tri[i])):
                tri[i][k] = stack.pop()

    print(f'#{test_case}')
    for lst in tri:
        print(*lst)

# 2 왼쪽과 위에 여유공간을 추가하고 arr[1][1]엔 1을 넣어주고 그 밑부터 왼쪽 위 + 위의 값을 더해주어 채워나가는 방식

'''
T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [[0]*(N+1) for _ in range(N+1)]

    arr[1][1] = 1
    for i in range(2, N+1):
        for j in range(1, i+1):
            arr[i][j] = arr[i-1][j-1]+arr[i-1][j]

    print(f'#{test_case}')
    for i in range(1, N+1):
        for j in range(1, i+1):
            print(arr[i][j], end=' ')
        print()
'''
```

---

## 종이붙이기 (Stack 1)

<img width="915" alt="aps_125" src="https://user-images.githubusercontent.com/86648892/187024636-ed6b5cf6-d721-43bd-a2a5-9b72f1a6f6b2.png">

<img width="920" alt="aps_126" src="https://user-images.githubusercontent.com/86648892/187024637-402cefa0-aee9-4caa-a0ef-c7d4f4436ada.png">

```python
# 리스트에 N마다의 값을 기록해두고 접근 (memoization)

T = int(input())
for test_case in range(1, T+1):
    N = int(input()) // 10
    # 각 N마다 종이를 붙일 수 있는 경우의 수를 기록해놓을 리스트
    # 편의상 N과 인덱스를 일치시키기 위해 N+1 길이만큼
    memo = [0] * (N+1)
    # 초기값
    memo[1] = 1
    memo[2] = 3
    # 점화식을 활용하여 결과값 기록
    # N번째 경우의 수는 N-1의 경우에 10x20짜리를 붙인 것 + N-2의 경우에 20x20짜리를 붙인 것
    # 정사각형의 경우 2개로 분할된 경우까지 고려해야 하므로 N의 경우의 수 == N-1의 경우의 수 + N-2의 경우의 수 * 2
    for i in range(3, N+1):
        memo[i] = memo[i-1] + memo[i-2]*2

    print(f'#{test_case} {memo[N]}')
```

---

## 괄호검사 2 (Stack 1)

<img width="906" alt="aps_127" src="https://user-images.githubusercontent.com/86648892/187024711-9904fb06-a19d-43a3-b410-65118964a85a.png">

```python
T = int(input())
for test_case in range(1, T+1):
    st = input()
    st_bracket = []
    stack = []
    ans = 1

    # 괄호만 있는 list 생성
    for char in st:
        if char=='(' or char==')' or char=='{' or char=='}':
            st_bracket.append(char)

    # stack을 이용해 판별
    for char in st_bracket:
        if char == '(' or char == '{':
            stack.append(char)
        else:
            if stack:   # 스택이 empty가 아님을 반드시 확인
                if char == ')' and stack[-1] == '(':
                    stack.pop()
                elif char == '}' and stack[-1] == '{':
                    stack.pop()
                else:   # 오류[1]: '('나 '{'가 남아있지만 매칭되지 않는 ')'나 '}'가 들어온 경우
                    ans = 0
                    break
            else:   # 오류[2]: ')'나 '}'가 들어왔지만 왼쪽 괄호가 없는 경우
                ans = 0
                break
    if stack:   # 오류[3]: 왼쪽 괄호가 남아있는 경우
        ans = 0

    print(f'#{test_case} {ans}')

# dictionary를 활용한 풀이
# 아이디어: 딕셔너리는 쌍이라는 점을 활용하여 괄호열기에 해당하는 괄호닫기를 스택에 추가하고, 괄호닫기가 나올 경우 해당 스택에서 pop된 것과 매칭이되야함을 이용
'''
T = int(input())
for test_case in range(1, T+1):
    dct = {'(': ')', '{': '}'}
    tbl = '})'
    st = input()
    ans = 1
    stack = []

    for char in st:
        if char in dct:                 # 괄호열기일 경우 (키 값)
            stack.append(dct[char])     # 해당 짝의 괄호닫기 추가
        elif char in tbl:               # 괄호닫기일 경우
            if stack and char == stack.pop():   # stack이 남아있고(내 코드 오류[2]에 해당), 들어온 괄호닫기가 stack에 있는 괄호열기와 쌍을 이루는 괄호닫기와 동일한 경우(내 코드 오류[1]에 해당)
                pass                    # 위의 stack.pop()은 값을 반환하여 비교에도 사용되지만, 그와 동시에 stack도 pop한 상태로 업데이트
            else:
                ans = 0
                break
    if stack:                           # 괄호열기가 남아있는 경우(내 코드 오류[3]에 해당)
        ans = 0
    
    print(f'#{test_case} {ans}')
'''
```

---

## 그래프 경로 (Stack 1)

<img width="934" alt="aps_128" src="https://user-images.githubusercontent.com/86648892/187024819-8d8506aa-dec5-4e5a-b71a-604bcfacfc12.png">

<img width="912" alt="aps_129" src="https://user-images.githubusercontent.com/86648892/187024820-6f30e44f-649e-43d7-8838-df9a4735d143.png">

```python
# dfs를 통한 경로 존재여부 탐색
# v는 출발지점, N은 정점개수+1 (1부터 노드번호가 있기에 인덱스 맞추기)
def dfs(v, N):
    arr = []
    top = -1
    arr.append(v)
    visited[v] = 1 # 시작점 방문 표시
    while True:
        for w in adjList[v]:        # 출발점의 인접 노드 검사
            if visited[w] == 0:     # 방문하지 않았다면
                top += 1
                stack[top] = v      # 이전 방문 지점에 S 추가
                v = w               # 출발점을 v로 변경
                arr.append(v)       # 경로에 값 추가
                visited[w] = 1      # v를 방문한 곳으로 변경
                break
        else:                       # 갈 곳이 없으면
            if top != -1:           # 그리고 돌아갈 곳이 있다면
                v = stack[top]      # 출발점 되돌리기 (pop)
                top -= 1
            else:                   # 돌아갈 곳도 없다면
                break               # 경로 탐색 종료
    return arr

T = int(input())
for test_case in range(1, T+1):
    V, E = map(int, input().split()) # 노드 개수, 간선 개수
    N = V+1
    adjList = [[] for _ in range(N)] # 인접원소 리스트 생성
    for _ in range(E):
        a, b = map(int, input().split())
        # 일방향 (양방향 아님)
        adjList[a].append(b)
    S, G = map(int, input().split()) # 출발 노드, 도착 노드

    visited = [0] * N # 방문 여부 표시
    stack = [0] * N # 이전 탐색 지점 저장용 스택

    # 경로 내에 G가 있다면 S에서 G로 가는 경로가 있는 것
    arr = dfs(S, N)     # test case #1의 경우 1에서 출발 G를 6으로 받음 # 결과는 arr = [1, 4, 6, 3] # 이는 1에서 일방향으로 갈 수 있는 지점을 담아놓은 것
    if G in arr:
        ans = 1
    else:
        ans = 0

    print(f'#{test_case} {ans}')

# 교수님 풀이

#1 stack 사용

'''
def dfs(s):
    stk = []

    visited[s] = 1

    while True:
        for e in adjL[s]:
            if not visited[e]:
                stk.append(s)   # 되돌아올 위치 push

                s = e
                visited[s]=1
                break
        else:
            if stk:
                s = stk.pop()
            else:
                break

# T = 10
T = int(input())
for test_case in range(1, T + 1):
    V, E = map(int, input().split())

    adjL = [[] for _ in range(V+1)] # 인접리스트로 연결상태 저장
    for _ in range(E):
        s, e = map(int, input().split())
        adjL[s].append(e)

    s, g = map(int, input().split())

    visited = [0]*(V+1)
    dfs(s)

    print(f'#{test_case} {visited[g]}')
'''

#2 재귀호출(recursive) 사용
# 라이브러리 사용하듯이 무슨 일을 시키는건지만 생각하자 (흐름을 따라가려 하다보면 망한다)
# 종료조건만 잘 설정하자

'''
def dfs_recur(s):
    # 기준에서 연결된 방문안한 노드 찾으면 방문
    # 일단 s를 방문하고
    for e in adjL[s]:           # s에서 갈 수 있는 곳 중
        if not visited[e]:      # 아직 안 간 곳을
            visited[e]=1        # (방문한 것으로 표시해주고)
            dfs_recur(e)        # 방문해줘

# T = 10
T = int(input())
for test_case in range(1, T + 1):
    V, E = map(int, input().split())

    adjL = [[] for _ in range(V+1)] # 인접리스트로 연결상태 저장
    for _ in range(E):
        s, e = map(int, input().split())
        adjL[s].append(e)

    s, g = map(int, input().split())

    visited = [0]*(V+1)
    dfs_recur(s)

    print(f'#{test_case} {visited[g]}')
'''
```

---

## 반복문자 지우기 (Stack 1)

<img width="905" alt="aps_130" src="https://user-images.githubusercontent.com/86648892/187026037-237a357f-9dfe-41e1-91c3-8d8cf7893cb3.png">

<img width="901" alt="aps_131" src="https://user-images.githubusercontent.com/86648892/187026041-e68b96e2-e963-4842-90e2-3aa7e6fab75a.png">

```python
T = int(input())
for test_case in range(1, T+1):
    word = input()
    stack = []

    for char in word:                   # 모든 문자열을 stack에 넣어주는 과정에서
        if stack:                       # stack이 빈 상태가 아니라면
            if char == stack[-1]:       # stack에 가장 최근 들어간 문자와 같다면 (연속된 것이므로)
                stack.pop()             # 제거해준다
            else:                       # stack에 가장 최근 들어간 문자와 같지 않다면 (연속되지 않은 것이므로)
                stack.append(char)      # 넣어준다
        else:                           # stack이 빈 상태라면
            stack.append(char)          # 넣어준다

    ans = len(stack)
    print(f'#{test_case} {ans}')

# 아래는 처음 풀었던 풀이
# 1) stack[-1]로 접근한 점은 좋았다
# 2) 어차피 문자열 역시 하나의 list이므로 chars = list(word)는 굳이 불필요하다
# 3) if stack: 을 통해 stack이 빈 상태가 아니라면 이라는 조건이 필요하다
# 3-1) 이런 조건을 걸면 자연스레 index error를 방지하고자 stack 맨 앞에 0을 넣고, stack[1:]을 출력할 필요도 없다

'''
T = int(input())
for test_case in range(1, T+1):
    word = input()
    chars = list(word)
    stack = [0]                         # index error 방지

    for i in range(len(chars)):         # 모든 문자열을 stack에 넣어주는 과정에서
        if chars[i] != stack[-1]:       # stack에 가장 최근 들어간 문자와 같지 않다면 (연속되지 않은 것이므로)
            stack.append(chars[i])      # 넣어준다
        else:                           # stack에 가장 최근 들어간 문자와 같다면 (연속된 것이므로)
            stack.pop()                 # 제거해준다

    ans = len(stack[1:])                # index error 방지용으로 넣었던 0을 뺀 원소의 수
    print(f'#{test_case} {ans}')
'''
```

---

## 길찾기 (DFS and BFS)

<img width="926" alt="aps_132" src="https://user-images.githubusercontent.com/86648892/187026156-4a7f3793-ce0a-4c36-8530-38090ea031b2.png">

<img width="935" alt="aps_133" src="https://user-images.githubusercontent.com/86648892/187026157-285c7df1-7672-4d63-b92d-831270ffb2f9.png">

<img width="921" alt="aps_134" src="https://user-images.githubusercontent.com/86648892/187026158-49afbc0c-7d1b-47a4-a499-1f21f7b18261.png">

<img width="924" alt="aps_135" src="https://user-images.githubusercontent.com/86648892/187026159-3e137f25-afb6-483b-80ca-06a14d11e46f.png">

<img width="907" alt="aps_136" src="https://user-images.githubusercontent.com/86648892/187026160-dbccce60-db34-45ae-8199-1628e1048a01.png">

### DFS
```python
def dfs(s):
    stack = []
    visited[s] = 1

    while True:
        for e in adjList[s]:
            if not visited[e]:
                stack.append(s)
                s = e
                visited[s] = 1
                break
        else:
            if stack:
                s = stack.pop()
            else:
                break

T = 10
for test_case in range(1, T+1):
    _, E = map(int, input().split())
    adjList1 = [0]*100
    adjList2 = [0]*100
    edges = list(map(int, input().split()))
    # 연결상태 저장(adjList1, adjList2)
    for i in range(E*2):
        if i % 2 == 0:
            if adjList1[edges[i]] == 0:
                adjList1[edges[i]] = edges[i+1]
            else:
                adjList2[edges[i]] = edges[i+1]
    adjList = list(map(list, zip(adjList1, adjList2)))

    visited = [0]*100
    dfs(0)

    print(f'#{test_case} {visited[99]}')
```

### BFS
```python
def bfs(v, N, t):   # v는 시작정점, N은 마지막정점, t는 찾는정점
    # visited 배열, queue 생성
    visited = [0]*(N+1)
    queue = []
    # 시작정점 기본작업
    queue.append(v)
    visited[v] = 1
    while queue:
        v = queue.pop(0)
        # 정점에 대한 작업
        if v == t:              # 목표 정점을 발견하면 1을 반환하고 종료 (목표 노드가 있는지 찾는 문제)
            return 1            # 목표 노드까지의 경로 여부 반환
            #return visited[t]  # 목표 노드까지 도달했을 때 경로의 길이 반환
        for w in adjList[v]:    # v에 인접한 원소 접근
            if visited[w] == 0: # 미방문지라면 이동
                queue.append(w)
                visited[w] = visited[v]+1
    return 0                # 목표 노드를 못찾으면 0 반환

T = 10
for _ in range(T):
    test_case, E = map(int, input().split())
    arr = list(map(int, input().split()))

    # 단방향 인접리스트 생성
    adjList = [[] for _ in range(100)]
    for i in range(E):
        a, b = arr[i*2], arr[i*2+1]
        adjList[a].append(b)

    ans = bfs(0, 99, 99)  # 시작, 마지막정점, 목표 정점번호

    print(f'#{test_case} {ans}')
```

---

## 의석이의 세로로 말해요 (IM)

<img width="902" alt="aps_137" src="https://user-images.githubusercontent.com/86648892/187026362-c6ad39e0-0b40-4bcb-b4ad-98d15d222b19.png">

<img width="933" alt="aps_138" src="https://user-images.githubusercontent.com/86648892/187026365-ffbecd5f-f60e-4a50-93be-75ec554a728f.png">

<img width="890" alt="aps_139" src="https://user-images.githubusercontent.com/86648892/187026369-5737178e-8705-4b6a-bccd-e56f9c9aff39.png">

```python
# 하기 코드의 가능한 개선방향
# 2차원 리스트를 활용하고, 좌표에 조건을 걸어 해당하지 않는 것은 수행하지 않음
# try-except를 활용

def pop_reverse_st(n):
    for i in range(5):
        if reverse_st[i]:
            result.append(reverse_st[i].pop())

T = int(input())
for test_case in range(1, T+1):
    st = [list(input()) for _ in range(5)]
    reverse_st = []
    result = [] # 세로로 읽은 결과 저장 리스트
    maxLen = 0

    # stack처럼 pop해주기 위해 역순으로된 문자열 리스트 생성
    for i in range(5):
        reverse_st.append(st[i][::-1])

    # 문자열 중 가장 긴 길이
    for arr in reverse_st:
        temp = len(arr)
        if temp > maxLen:
            maxLen = temp

    # 가장 긴 길이만큼 세로순으로 pop 시도
    for i in range(maxLen):
        pop_reverse_st(5)

    ans = ''.join(result)
    print(f'#{test_case} {ans}')
```

---

## 쇠막대기 자르기 (IM)

<img width="970" alt="aps_140" src="https://user-images.githubusercontent.com/86648892/187029457-da7bcede-bc44-4906-bd8e-d031f5263a13.png">

<img width="904" alt="aps_141" src="https://user-images.githubusercontent.com/86648892/187029459-4b041246-2a5b-4018-b842-a3c426d6df01.png">

```python
T = int(input())
for test_case in range(1, T+1):
    st = input()
    i = 0
    num = 0     # 쌓여있는 막대기 개수
    total = 0   # 조각의 개수

    # [1] '()' 레이저라면 현재 쌓여있는 막대기 수만큼 조각 수를 늘림
    # [2] '(' 라면 현재 쌓여있는 막대기에 하나를 더하고, 조각 수도 하나 늘림
    # [3] ')' 라면 현재 쌓여있는 막대기를 하나 없앰

    while i < len(st):
        if st[i] == '(' and st[i+1] == ')': # [1]이라면 시작위치를 2만큼 이동 (레이저는 두 글자이므로)
            total += num
            i += 2
        elif st[i] == '(':                  # [2]라면 시작위치를 1만큼 이동
            total += 1
            num += 1
            i += 1
        elif st[i] == ')':                  # [3]이라면 시작위치를 1만큼 이동
            num -= 1
            i += 1
    print(f'#{test_case} {total}')

    # 인덱스가 넘어가는 경우를 생각하기 싫어서 while을 사용하였지만
    # for문을 사용하면서 적절히 슬라이싱하거나 index를 가지고 놀아주는 생각도 해보자
```

---

## 백만장자 프로젝트 (IM)

<img width="908" alt="aps_142" src="https://user-images.githubusercontent.com/86648892/187029533-530a0f18-0e01-4cd4-9fc1-d83f31fc7b08.png">

<img width="909" alt="aps_143" src="https://user-images.githubusercontent.com/86648892/187029538-dd4a64d1-f3a1-4fca-aecf-e06f0be33854.png">

```python
# 이익 = 가장 큰 값을 가지는 값의 인덱스 기준 왼쪽 인덱스들의 값들과 가장 큰 값의 차이들의 합
# 가장 큰 값의 인덱스의 오른쪽으로 출발 지점을 업데이트
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    arr = list(map(int, input().split()))
    s = 0       # 출발 인덱스
    ans = 0     # 이익의 합
    while s < N:
        max_idx = s                         # 처음엔 0, 이후엔 바뀌어진 max_idx 반영
        for i in range(s+1, N):             # 처음엔 0부터, 이후엔 계산된 최대값 이후부터 다시 계산
            if arr[i] > arr[max_idx]:       # 최대값의 인덱스 업데이트
                max_idx = i
        for i in range(s, max_idx):         # 출발 지점부터 최대값이 있는 곳 전까지 각각의 값에 대하여
            ans += (arr[max_idx] - arr[i])  # 최대값과의 차(이익)를 ans(이익의 합)에 더해줌
        s = max_idx + 1                     # 출발 지점을 최대값 이후로 업데이트 (최대값 위치에 변화가 없었다면 출발 지점을 오른쪽으로 +1)
    print(f'#{test_case} {ans}')
```

---

## 비밀번호 (IM)

<img width="912" alt="aps_144" src="https://user-images.githubusercontent.com/86648892/187029629-d60ad175-f91d-4828-97e7-c09fffb4b6e7.png">

<img width="913" alt="aps_145" src="https://user-images.githubusercontent.com/86648892/187029630-87eded9e-7864-46eb-ac32-fcdf71f71bb7.png">

<img width="910" alt="aps_146" src="https://user-images.githubusercontent.com/86648892/187029631-c8542f60-22a4-4e7a-9537-8699b6ddc842.png">

```python
T = 10
for test_case in range(1, T+1):
    n, st = input().split()
    N = int(n)
    stack = []
    for num in st:
        if stack:
            if num == stack[-1]:
                stack.pop()
            else:
                stack.append(num)
        else:
            stack.append(num)

    ans = ''.join(stack)
    print(f'#{test_case} {ans}')
```

---

## 농작물 수확하기 (IM)

<img width="931" alt="aps_147" src="https://user-images.githubusercontent.com/86648892/187029689-cd8e8707-847f-4b55-9c26-ad17978c83a9.png">

<img width="927" alt="aps_148" src="https://user-images.githubusercontent.com/86648892/187029693-45f13fd6-9400-4974-8755-65aa433993ac.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    farm = [list(map(int, input())) for _ in range(N)]
    farm_reverse = []
    for i in range(N):
        farm_reverse.append(farm[i][::-1])
    total = 0
    total_l = 0
    total_r = 0

    # 전체 수익
    for i in range(N):
        for j in range(N):
            total += farm[i][j]

    # 왼쪽 빠지는 부분 수익 (from farm)
    for i in range(N):
        temp = abs((N//2) - i)
        for j in range(temp):
            total_l += farm[i][j]

    # 오른쪽 빠지는 부분 수익 (from farm_reverse)
    for i in range(N):
        temp = abs((N//2) - i)
        for j in range(temp):
            total_r += farm_reverse[i][j]

    # 수익 = 전체가능수익 - 빠지는 수익
    ans = total - total_l - total_r
    print(f'#{test_case} {ans}')

'''
M = N // 2

# 1 기본적인 방법 (i좌표와 j좌표 간의 규칙성 찾기) (이를 통해 해당 부분 더해주기)

T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input())) for _ in range(N)]
    M = N//2
    ans = 0

    for i in range(N):
        if i<=M:
            for j in range(M-i, M+i+1):
                ans += arr[i][j]
        else:
            for j in range(i-M, N-(i-M)):
                ans += arr[i][j]
    print(f'#{test_case} {ans}')
'''

'''
M = N // 2
s = 행의 해당 부분 출발점
e = 행의 해당 부분 끝점

# 2 start index와 end index를 조절하는 방법

T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input())) for _ in range(N)]
    s = e = M = N//2
    ans = 0

    for i in range(N):
        for j in range(s, e+1):
            ans += arr[i][j]
        if i<M:
            s -= 1
            e += 1
        else:
            s += 1
            e -= 1
    print(f'#{test_case} {ans}')
'''
```

---

## Ladder 2 (IM)

<img width="923" alt="aps_149" src="https://user-images.githubusercontent.com/86648892/187029796-14f23620-d62c-4b0a-80ba-b30d5782239b.png">

<img width="920" alt="aps_150" src="https://user-images.githubusercontent.com/86648892/187029800-c24618bd-8824-45bc-8f09-804f3bdf7b16.png">

<img width="935" alt="aps_151" src="https://user-images.githubusercontent.com/86648892/187029803-389afd74-092e-452e-a0b9-5522e527506b.png">

<img width="917" alt="aps_152" src="https://user-images.githubusercontent.com/86648892/187029804-214f58ee-37f9-42d2-ac8a-c0971d059a39.png">

```python
T = 10
for test_case in range(1, T+1):
    N = int(input())
    # 양쪽에 0으로 padding
    ladder = [[0] + list(map(int, input().split())) + [0] for _ in range(100)]
    di = [1, 0, 0]  # 하 좌 우
    dj = [0, -1, 1]
    dr = 0          # 하 방향으로 초기화
    start = []      # 가능한 출발지점
    cnts = dict()         # x와 거리
    cnt = 0

    # 출발 가능한 x 파악
    for x in range(1, 101):
        if ladder[0][x] == 1:
            start.append(x)

    # 각 출발 지점에 대하여
    for x in start:
        # 출발 인덱스
        ci = 0
        cj = x
        cnt = 0

        # 이동
        while ci < 99:
            ni = ci + di[dr]
            nj = cj + dj[dr]

            if dr == 0:             # 아래로 가는 중
                if ladder[ni][nj-1] == 1:   # 왼쪽에 1이 있다면
                    ci = ni
                    cj = nj
                    dr = 1
                    cnt += 1
                elif ladder[ni][nj+1] == 1: # 오른쪽에 1이 있다면
                    ci = ni
                    cj = nj
                    dr = 2
                    cnt += 1
                else:                       # 둘다 없다면 그대로 아래로 진행
                    ci = ni
                    cj = nj
                    cnt += 1
            elif dr == 1:           # 왼쪽으로 가는 중
                if ladder[ni][nj-1] == 0:
                    ci = ni                 # 다음 왼쪽 칸이 0으로 막혀있다면
                    cj = nj
                    dr = 0
                    cnt += 1
                else:                       # 갈 곳이 있다면 그대로 진행
                    ci = ni
                    cj = nj
                    cnt += 1
            elif dr == 2:           # 오른쪽으로 가는 중
                if ladder[ni][nj+1] == 0:   # 다음 오른쪽 칸이 0으로 막혀있다면
                    ci = ni
                    cj = nj
                    dr = 0
                    cnt += 1
                else:                       # 갈 곳이 있다면 그대로 진행
                    ci = ni
                    cj = nj
                    cnt += 1
        cnts[x] = cnt

    # 최단거리 찾기
    min_x = start[0]
    for x in cnts:
        if cnts[x] <= cnts[min_x]:
            min_x = x

    # padding을 줬으므로 x좌표 -1
    ans = min_x - 1
    print(f'#{test_case} {ans}')

'''
# 교수님 풀이
# 같은 아이디어
# 개선점
# 1) 출발해야되는 x좌표를 따로 리스트에 저장하는 것이 아니라 for문에서 continue를 사용하여 해당하지 않는 x좌표의 경우 for문 이하 코드를 실행하지 않도록 설정
# 2) 코드 간소화

T = 10
# T = int(input())
for test_case in range(1, T + 1):
    _ = input()
    arr = [[0]+list(map(int, input().split()))+[0] for _ in range(100)]
    mx = 100*100

    # j==1부터 100까지 1을 만나면 탐색시작
    for sj in range(1, 101):
        if arr[0][sj] == 0:
            continue

        cj = sj
        ci = cnt = dj = 0
        while ci < 99:
            cnt += 1
            if dj == 0: # 아래방향: 이동 후 방향 설정
                ci += 1   # [1] 이동
                if arr[ci][cj-1]==1:    # 좌측에 길 있음
                    dj = -1
                elif arr[ci][cj+1]==1:  # 우측에 길
                    dj = 1
            else:       # 좌 / 우 방향
                cj += dj    # [1] 이동
                if arr[ci][cj+dj]==0:   # 막다른 길 -> 아래
                    dj = 0
        if mx >= cnt:  # 같은 거리면 높은 좌표값이 정답
            mx, ans = cnt, sj-1

    print(f'#{test_case} {ans}') # 정답은 -1한 좌표
'''
```

---

## 후위표기법 변환 (Stack 2)

<img width="900" alt="aps_153" src="https://user-images.githubusercontent.com/86648892/187029956-3abeaf85-b71e-4a7e-b86c-211248f77b07.png">

```python
T = int(input())
for test_case in range(1, T+1):
    st = input()                    # 입력받은 문자열
    priority = {'*': 2, '+': 1}     # 우선순위 설정
    stack = []                      # 연산자용 스택
    ans = ''                        # 출력할 문자열
    for i in range(len(st)):        # 문자열 길이만큼 수행
        if st[i] == '*' or st[i] == '+':    # 연산자라면
            while stack and priority[st[i]] <= priority[stack[-1]]: # 현재 연산자가 스택에 있는 연산자보다 우선순위가 크지 않을 때까지
                ans += stack.pop()                                  # 스택의 연산자가 더 우선순위가 높으므로 pop하여 추가
            stack.append(st[i])                                     # 우선순위가 더 높은 연산자 다 빼주고 스택에 현제 연산자 추가
        else:                       # 숫자라면 출력용 문자열에 추가
            ans += st[i]
    while len(stack) != 0:          # stack에 남아있는 연산자 추가
        ans += stack.pop()

    print(f'#{test_case} {ans}')

# 교수님 풀이
'''
pri = {'+':1, '*':2}
# T = 10
T = int(input())
for test_case in range(1, T + 1):
    # _ = input()
    st = input()

    equ = ''
    stk = []
    # [1] 중위표기식 -> 후위표기식
    for ch in st:
        if ch.isdigit():    # 숫자인 경우: equ에 추가
            equ += ch
        else:   # 연산자인 경우
            if not stk:
                stk.append(ch)
            else:
                if pri[ch] > pri[stk[-1]]:
                    stk.append(ch)
                else:
                    while stk and pri[ch] <= pri[stk[-1]]:
                        equ += stk.pop()
                    stk.append(ch)

    # [2] 남은 연산자를 순서대로 pop, equ에 추가
    while stk:
        equ += stk.pop()

    print(f'#{test_case} {equ}')
'''

# 교수님 풀이 2
'''
pri = {'+':1, '*':2}
# T = 10
T = int(input())
for test_case in range(1, T + 1):
    # _ = input()
    st = input()

    equ = ''
    stk = []
    # [1] 중위표기식 -> 후위표기식
    for ch in st:
        if ch.isdigit():    # 숫자인 경우: equ에 추가
            equ += ch
        else:   # 연산자인 경우
            while stk and pri[ch] <= pri[stk[-1]]:
                equ += stk.pop()
            stk.append(ch)

    # [2] 남은 연산자를 순서대로 pop, equ에 추가
    while stk:
        equ += stk.pop()

    print(f'#{test_case} {equ}')
'''
```

---

## 원소의 합이 K인 부분집합 개수 (Stack 2)

<img width="907" alt="aps_154" src="https://user-images.githubusercontent.com/86648892/187030033-2102b251-18e9-4085-8345-cfdf914f1b0a.png">

```python
# 부분집합의 인덱스 0번 원소부터 시작
# 인덱스 0번 원소에서 출발 -> 아직 N이 아니네? -> 해당 0번 원소를 포함 / 비포함으로 나누어 각각 해당 경우로 다시 함수 실행
# 0번 원소가 포함된 경우에서 1번 원소가 포함 / 비포함으로 쪼개지고, 0번 원소가 포함되지 않은 경우에서 1번 원소가 포함 / 비포함으로 쪼개짐
# 이를 반복하여 N-1까지 갈 경우(끝 원소) 해당 원소에 대해 다시 포함 / 비포함으로 나누고
# 여기서 i+1을 하면 이제 i == N에 걸림
# 모든 부분집합의 케이스들에 대하여 i == N 이하의 항목이 실행됨

def search_subset(i, N):
    global ans                          # ans값을 변경시켜줘야하므로 global
    if i == N:                          # 모든 원소에 대해 판단 (재귀가 N까지 도달할 때까지)
        s = 0                           # 합 (각 케이스 검사 시 0으로 초기화)
        for i in range(N):              # 해당 케이스 각 비트 검사 (포함 여부 검사)
            if bit[i] == 1:             # 해당 원소가 포함이라면
                s += lst[i]             # 합에 추가
        if s == K:                      # 해당 케이스 합이 K와 같다면
            ans += 1                    # 경우의 수 +1
    else:                               # 모든 원소에 아직 접근한 것이 아니라면
        bit[i] = 1                      # 해당 원소(lst[i]) 포함하는 경우
        search_subset(i+1, N)           # 해당 원소를 포함하는 경우로 recursion
        bit[i] = 0                      # 해당 원소(lst[i]) 포함하지 않는 경우
        search_subset(i+1, N)           # 해당 원소를 포함하지 않는 경우로 recursion

T = int(input())
for test_case in range(1, T+1):
    N, K = map(int, input().split())        # N은 전체 리스트 길이, K는 부분집합의 합 타겟값
    lst = list(map(int, input().split()))
    bit = [0] * N                           # 각 원소의 포함 여부
    ans = 0                                 # 부분집합의 합 K와 일치 횟수
    search_subset(0, N)
    print(f'#{test_case} {ans}')

# 교수님 풀이
# 1) 나는 포함여부를 나타내는 bit를 사용했다면, 교수님은 바로 sum으로 재귀
# 2) return을 잘 써주자
'''
def dfs(n, sm):
    global ans

    # 종료조건
    if n==N:
        if sm == K:
            ans += 1
        return

    # dfs(n+1) 호출
    dfs(n+1, sm+lst[n]) # 사용하는 경우
    dfs(n+1, sm)        # 사용하지 않는 경우

# T = 10
T = int(input())
for test_case in range(1, T + 1):
    N, K = map(int, input().split())
    lst = list(map(int, input().split()))
    ans = 0

    dfs(0, 0)

    print(f'#{test_case} {ans}')
'''

# 교수님 풀이2 (가지치기)
# 가지치기는 테스트 케이스의 수가 클 때 필수
'''
def dfs(n, sm):
    global ans

    # 가지치기는 제일 위에서, 제일 마지막 순서로
    if sm > K:  # 이미 K값 초과해서 답을 찾을 가능성이 없는 경우
        return

    # 종료조건
    if n==N:
        if sm == K:
            ans += 1
        return

    # dfs(n+1) 호출
    dfs(n+1, sm+lst[n]) # 사용하는 경우
    dfs(n+1, sm)        # 사용하지 않는 경우

# T = 10
T = int(input())
for test_case in range(1, T + 1):
    N, K = map(int, input().split())
    lst = list(map(int, input().split()))
    ans = 0

    dfs(0, 0)

    print(f'#{test_case} {ans}')
'''
```

---

## 계산기2 (후위표기식 변환 및 계산) (Stack 2)

<img width="913" alt="aps_155" src="https://user-images.githubusercontent.com/86648892/187030135-87511529-f5d0-4f29-90bb-c8546306252c.png">

```python
T = 10
for test_case in range(1, T+1):
    N = int(input())
    st = input()
    priority = {'*': 2, '+': 1}     # 우선순위 설정
    stack1 = []                     # 연산자용 스택
    stack2 = []                     # 피연산자용 스택
    postfix = ''                    # 후위표기식

    # 후위표기식 생성
    for i in range(N):        # 문자열 길이만큼 수행
        if st[i] == '*' or st[i] == '+':    # 연산자라면
            while stack1 and priority[st[i]] <= priority[stack1[-1]]:   # 현재 연산자가 스택에 있는 연산자보다 우선순위가 크지 않을 때까지
                postfix += stack1.pop()                                 # 스택의 연산자가 더 우선순위가 높으므로 pop하여 추가
            stack1.append(st[i])                                        # 우선순위가 더 높은 연산자 다 빼주고 스택에 현제 연산자 추가
        else:                       # 숫자라면 후위표기 문자열에 바로 추가
            postfix += st[i]
    while len(stack1) != 0:         # stack에 남아있는 연산자 추가
        postfix += stack1.pop()

    # 후위표기식 계산
    for char in postfix:
        if char == '*':     # '*' 연산자라면 피연산자의 최근 2개의 숫자를 곱하고 다시 push
            temp = int(stack2.pop()) * int(stack2.pop())
            stack2.append(str(temp))
        elif char == '+':   # '+' 연산자라면 피연산자의 최근 2개의 숫자를 더하고 다시 push
            temp = int(stack2.pop()) + int(stack2.pop())
            stack2.append(str(temp))
        else:               # 피연산자라면 stack2(피연산자용 스택)에 추가
            stack2.append(char)

    ans = stack2.pop()      # 마지막에 남은 값이 계산된 값
    print(f'#{test_case} {ans}')

# 교수님 풀이
# 1) 어차피 후위표기식을 만들 때 사용하는 스택은 결국 모두 원소를 빼낼 것이므로 피연산자용 스택을 따로 만들 필요 없음
# 2) operand의 순서를 잘 설정해놓자
'''
pri = {'+':1, '*':2}
T = 10
# T = int(input())
for test_case in range(1, T + 1):
    _ = input()
    st = input()

    equ = ''
    stk = []
    # [1] 중위표기식 -> 후위표기식
    for ch in st:
        if ch.isdigit():    # 숫자인 경우: equ에 추가
            equ += ch
        else:   # 연산자인 경우
            while stk and pri[ch] <= pri[stk[-1]]:
                equ += stk.pop()
            stk.append(ch)

    # 잊지말고 처리: 남은 연산자를 순서대로 pop, equ에 추가
    while stk:
        equ += stk.pop()

    # [2] 후위표기식 계산
    for ch in equ:
        if ch.isdigit():
            stk.append(int(ch))         # 계산을 위해 int로 변형하여 append
        else:
            op2 = stk.pop()             # operand
            op1 = stk.pop()
            if ch == '+':
                stk.append(op1+op2)     # 순서는 op1+op2라는 것을 명심 ('-' 나 '/'일 경우 값이 달라짐) # 먼저 들어가있는 것(스택에서 나중에 pop되는 것)이 연산에서 앞의 항
            elif ch == '*':
                stk.append(op1*op2)

    print(f'#{test_case} {stk.pop()}')
'''
```

---

## Forth (Stack 2)

<img width="940" alt="aps_156" src="https://user-images.githubusercontent.com/86648892/187030236-0f967772-141e-4181-97b1-0dba973cb4bc.png">

<img width="916" alt="aps_157" src="https://user-images.githubusercontent.com/86648892/187030237-ad40ed47-12af-4302-95de-399179781dfe.png">

```python
# error가 발생하는 경우 [1] 연산자 pop을 했는데 스택이 empty인 경우 [2] 모든 동작을 종료했는데 스택에 값이 남아있는 경우
# try-except를 사용하지 않을 것이면 pop()하는 위치마다 에러처리를 해주면 된다
T = int(input())
for test_case in range(1, T+1):
    postfix = input().split()
    stk = []
    for char in postfix:
        # 숫자일 경우
        if char.isdigit():
            stk.append(int(char))
        # 연산자일 경우
        else:
            # [1] 처리
            try:
                if char == '.':
                    ans = stk.pop()
                else:
                    op2 = stk.pop()
                    op1 = stk.pop()
                    if char == '+':
                        stk.append(op1+op2)
                    elif char == '-':
                        stk.append(op1-op2)
                    elif char == '*':
                        stk.append(op1*op2)
                    elif char == '/':
                        stk.append(op1//op2)
                    else:
                        ans = 'error'
                        break
            except:
                ans = 'error'
    # [2] 처리
    if stk:
        ans = 'error'
    print(f'#{test_case} {ans}')
```

---

## 미로 (DFS and BFS)

<img width="935" alt="aps_158" src="https://user-images.githubusercontent.com/86648892/187030307-defad46d-75fe-43eb-acaf-b0c74933d03d.png">

<img width="923" alt="aps_159" src="https://user-images.githubusercontent.com/86648892/187030308-c675c353-6395-4eda-87ee-f2e4213f114f.png">

### DFS, 경로 여부
```python
# 그래프 경로는 연결리스트로 dfs 수행
# 미로는 4방향으로 dfs 수행
# dfs에서의 단위작업은 1) 기준점 s잡기 2) visited[s]를 방문 표시 3) 스택 생성 및 돌아갈 지점 push 4) 그 외 할일

def dfs(si, sj):
    stk = []
    visited[si][sj] = 1

    while True:
        # 상하좌우 네방향에 대하여, 미방문지이고, 길이면(벽이 아니라면)
        for di, dj in ((-1,0), (1,0), (0,-1), (0,1)):
            ni, nj = si+di, sj+dj   # 다음에 갈 지점
            if 0<=ni<N and 0<=nj<N and not visited[ni][nj] and arr[ni][nj]!='1':
                stk.append((si, sj))

                si, sj = ni, nj     # 탐색 기준점 변경
                visited[ni][nj] = 1 # 방문 표시
                break
        # 갈 곳을 못찾았다면(네방향 모두 갈 곳이 없다면)
        else:
            if stk:     # 이전 지점으로 간다
                si, sj = stk.pop()
            else:       # 갈 곳도 없고 이전 지점도 없다면 경로 탐색을 종료
                break

# 재귀함수
# 재귀는 일종의 라이브러리처럼 사용해라 (뒤에 일은 너에게 맡긴다)
def dfs_recur(si, sj):
    for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):
        ni, nj = si + di, sj + dj
        if 0 <= ni < N and 0 <= nj < N and not visited[ni][nj] and arr[ni][nj] != '1':      # 상하좌우로 이동가능한 곳에 이동하여
            visited[ni][nj] = 1     # 이동한 곳에 방문표시
            dfs_recur(ni,nj)        # 이동가능한 곳에 관하여 다시 이동가능한 곳 탐색하여 방문표시 (이렇게 하면 이동가능한 모든 경우에 대해 반복적으로 이동, 방문표시 수행) (목표지점이 이동가능한 경우라면 이 곳 역시 방문표시가 1로 변경되어있을 것)

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    arr = [input() for _ in range(N)]

    # [1] 출발지, 목적지 찾기
    for i in range(N):
        for j in range(N):
            if arr[i][j] == '2':
                si, sj = i, j
            elif arr[i][j] == '3':
                ei, ej = i, j
    
    # [2] visited 배열 초기화 후 전체 방문표시
    visited = [[0]*N for _ in range(N)]
    dfs(si, sj)
    #dfs_recur(si, sj)

    # visited[ei][ej]에 도달했다면 1일 것이고, 아니면 0일 것
    print(f'#{test_case} {visited[ei][ej]}')
```

### BFS, 경로 여부
```python
def bfs(si, sj, N):
    visited = [[0]*N for _ in range(N)]
    queue = []
    # 시작점
    queue.append((si, sj))
    visited[si][sj] = 1
    # 모두 순회할동안 타겟을 찾으면 1 반환 그렇지 않다면 0 반환
    while queue:
        ci, cj = queue.pop(0)
        # 목표작업 수행
        if maze[ci][cj] == 3:       # 도착좌표에 도착했다면
            return 1               # 1 반환하고 종료 (경로 있음)
        for di, dj in ((-1,0), (1,0), (0,-1), (0,1)):   # 4방향 탐색
            ni, nj = ci+di, cj+dj
            # 범위 내, 벽이 아니고, 미방문지라면
            if 0<=ni<N and 0<=nj<N and maze[ni][nj]!=1 and visited[ni][nj]==0:
                queue.append((ni, nj))
                visited[ni][nj] = visited[ci][cj] + 1
    return 0                       # 0 반환하고 종료 (경로 없음)

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    maze = [list(map(int, input())) for _ in range(N)]
    
    # 시작점 찾기
    si, sj = -1, -1
    for i in range(N):
        for j in range(N):
            if maze[i][j] == 2:
                si, sj = i, j
                break
        if si != -1:
            break
    
    ans = bfs(si, sj, N)
    print(f'#{test_case} {ans}')
```

---

## 토너먼트 카드게임 (재귀, lookup table)

<img width="951" alt="aps_160" src="https://user-images.githubusercontent.com/86648892/187030625-04f9af99-c990-485e-bd2e-29fe3e60c10e.png">

<img width="924" alt="aps_161" src="https://user-images.githubusercontent.com/86648892/187030629-814e29da-d70f-4eef-b3ad-18d9c7e31d56.png">

```python
# 재귀라면
# 1) 항상 종료조건이 있어야 한다
# 2) 하부호출(나를 쪼개서 호출한다!), 그리고 최소한의 단위작업 (단위작업은 트리 구조에 있어 여러 개의 덩어리 중 한 덩어리) (이 한 덩어리를 코드로 구현해주면 된다!)
# 3) 나머지는 라이브러리처럼 다음 기준에게 맡김

# 가위바위보 토너먼트
# 1) s == e가 되는 경우가 종료조건
# 2) 단위작업은 왼쪽의 승자, 오른쪽의 승자를 찾는 것
# 3) 하부호출

# lookup table (가위바위보 승리판별용) 1은 가위, 2는 바위, 3은 보
tbl = [0, 2, 3, 1]
def rsp(s, e):
    # [1] 종료조건 (s, e가 같아진다는 것은 승리자가 한 명이 남았을 때)
    if s == e:
        return s
    
    # [2] 하부호출, 단위작업: 2등분해서 왼쪽과 오른쪽 각각의 승자를 가리고, 둘 간 최종승자를 가림
    l_winner = rsp(s, (s+e)//2)     # 밑의 친구야 왼쪽의 승자를 찾아줘
    r_winner = rsp((s+e)//2+1, e)   # 밑의 친구야 오른쪽의 승자를 찾아줘

    # 밑에서 불러온 왼쪽 승자, 오른쪽 승자를 바탕으로 최종승자 판별
    if tbl[lst[l_winner]] == lst[r_winner]: # b가 이긴 경우
        return r_winner
    else:                                   # 비기거나 a가 이긴 경우 a가 승자 (조건에서 비긴 경우 왼쪽 승자를 반환하기로 함)
        return l_winner

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    lst = [0] + list(map(int, input().split())) # 인덱스와 사람 번호를 맞추기 위해 [0] 앞에 추가

    ans = rsp(1, N) # 1 ~ N 사이의 최종 승리자의 index를 리턴 (rsp가 하는 일)

    print(f'#{test_case} {ans}')
```

---

## 배열 최소 합 (DFS)

<img width="906" alt="aps_162" src="https://user-images.githubusercontent.com/86648892/187030700-0114b8a3-0758-4854-a21e-3e6d1413d571.png">

<img width="909" alt="aps_163" src="https://user-images.githubusercontent.com/86648892/187030702-a0e7791c-366b-4949-ac5f-bfaa953ee996.png">

```python
# dfs(i, sm)은 합 정보 sm을 담은 채 i으로 가라는 것
# 필요한 작업만 해주고 (열 중복 방지)
# dfs(i+1, sm+arr[i][j])는 새로운 합 정보 sm+arr[i][j]를 담은 채 i+1로 가라는 것, 가고 나서는 너에게 맡긴다 느낌
# 가지치기를 하지 않을 경우 시간초과로 runtime error가 발생할 수 있다!
# 가지치기는 이 문제와 같이 최소값을 구하는 문제가 많다

def dfs(i, sm):
    global ans              # ans 업데이트를 위해 global 선언
    # 가지치기
    if ans <= sm:           # 현재 합이 이미 ans보다 큰 경우: 정답 갱신 가능성 없음
        return
    # 종료조건
    if i == N:
        if ans > sm:        # 해당 케이스의 합이 현재 ans보다 작을 경우 최소값 최신화
            ans = sm
        return
    # 하부호출, 단위작업
    for j in range(N):              # 해당 행의 각 칸(열)에 위치한 경우
        if not visited[j]:          # 해당 열이 이전 행과 중복되지 않는 경우에만 수행
            visited[j] = 1          # 다음 행에서 중복을 방지
            dfs(i+1, sm+arr[i][j])  # sm에 행의 값을 담은 채 다음 행으로 이동 (N-1행까지 도달할 때까지 이동, 모든 케이스 생성)
            visited[j] = 0          # 위에서 해당 j가 1인 경우를 이미 dfs()로 뿌려줬으니, 다른 j가 for문에 들어올 경우는 또 다른 케이스이므로 0으로 최신화해놓아야 함


T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    visited = [0]*N     # 열의 개수만큼 필요 (이미 방문한 열은 제외하기 위해)
    ans = 10*N          # 3 <= N <= 10이므로 가능한 최대합은 10*N
    dfs(0, 0)           # i==0 (0행), sum = 0

    print(f'#{test_case} {ans}')
```

---

## 계산기 3 (후위표기식 변환 및 계산) (icp, isp) (Stack 2)

<img width="902" alt="aps_164" src="https://user-images.githubusercontent.com/86648892/187030752-3fce88a8-8b68-4d23-8bc0-672657498968.png">

<img width="900" alt="aps_165" src="https://user-images.githubusercontent.com/86648892/187030758-eea0b6dc-7a79-48f5-99d8-bedd236d9a13.png">

```python
icp = {'(': 3, '*': 2, '+': 1}  # 입력되는 연산자의 우선순위
isp = {'(': 0, '*': 2, '+': 1}  # 스택에 있는 연산자의 우선순위
T = 10
for test_case in range(1, T+1):
    N = int(input())
    st = input()

    postfix = ''
    stack = []

    # 중위표기식 -> 후위표기식
    for char in st:
        if char.isdigit():  # 숫자인 경우 postfix에 추가
            postfix += char
        elif char == ')':   # 닫는 괄호일 경우
            while stack and stack[-1] != '(':   # 여는 괄호를 만날 때까지
                postfix += stack.pop()          # 연산자를 모두 처리
            stack.pop()                         # 닫는 괄호와 쌍을 이루는 여는 괄호 버림
        else:               # 이외 연산자일 경우
            while stack and icp[char] <= isp[stack[-1]]:    # 들어오는 연산자와 스택 내 연산자의 우선순위 비교
                postfix += stack.pop()                      # 스택 내 우선순위가 더 높은 연산자 우선 처리 후
            stack.append(char)                              # 들어오는 연산자 스택에 추가
    # 남은 연산자 처리
    while stack:
        postfix += stack.pop()

    # 후위표기식 계산
    for char in postfix:
        if char.isdigit():
            stack.append(int(char))     # 계산을 위해 int로 변형
        else:
            op2 = stack.pop()           # operand
            op1 = stack.pop()
            if char == '+':
                stack.append(op1+op2)
            elif char == '*':
                stack.append(op1*op2)

    # 마지막에 스택에 남아있는 숫자가 연산 결과
    ans = stack.pop()
    print(f'#{test_case} {ans}')
```

---

## 너비우선탐색 (Queue)

<img width="909" alt="aps_166" src="https://user-images.githubusercontent.com/86648892/187030842-de1e74cb-7ef5-4847-bf2f-603eb649027f.png">

<img width="934" alt="aps_167" src="https://user-images.githubusercontent.com/86648892/187030847-48d78a7d-cb1b-47fb-ac31-f5221edcf293.png">

```python
def bfs(s):
    # [1] q, visited, 필요한 flag 초기화
    q = []
    visited = [0]*(V+1)

    # [2] 초기데이터(들)를 q에 삽입 (+ 단위작업: visited 표시, sols 처리 등)
    q.append(s)
    visited[s] = 1
    sols.append(s)

    while q:    # q에 데이터가 있는 동안 반복
        s = q.pop(0)    # 제일 앞(FIFO)에서 데이터 꺼냄
        # 정답처리가 필요한 경우 이 자리에서..

        # [3] 4방향, 8방향, 연결된 노드 등 미방문, 조건에 맞는 곳이면 작업 수행
        for e in range(1, V+1):
            if e in adjL[s] and not visited[e]:
                q.append(e)
                visited[e] = 1
                sols.append(e)
T = int(input())
for test_case in range(1, T+1):
    V, E = map(int, input().split())
    # 인접리스트에 연결된 노드 추가 (양방향)
    adjL = [[]*(V+1) for _ in range(V+1)]
    for _ in range(E):
        s, e = map(int, input().split())
        adjL[s].append(e)
        adjL[e].append(s)

    sols = []
    bfs(1)  # 시작지점 1, 방문 순서대로 sols에 추가
    print(f'#{test_case}', *sols)
```

---

## 암호생성기 (Queue)

<img width="904" alt="aps_168" src="https://user-images.githubusercontent.com/86648892/187031070-f98157d0-3444-45ae-8a30-2bb949079f82.png">

<img width="905" alt="aps_169" src="https://user-images.githubusercontent.com/86648892/187031072-a4988b19-5d07-40ac-8ca5-9a082f1accb3.png">

<img width="911" alt="aps_170" src="https://user-images.githubusercontent.com/86648892/187031074-32ed8cfb-c49d-433b-97b2-a463e01e3a2e.png">

<img width="909" alt="aps_171" src="https://user-images.githubusercontent.com/86648892/187031079-9c66f2ab-a20a-4ebb-b690-cd761e91abf7.png">

```python
#from collections import deque              # deque() 사용시 필요
T = 10
for test_case in range(1, T+1):
    _ = int(input())
    queue = list(map(int, input().split())) # queue 생성
    #arr = list(map(int, input().split()))
    #queue = deque(arr)                     # deque 객체 생성

    # 작업 수행
    i = 1
    while True:
        if i > 5:                   # 사이클 완료 시 빼주는 값 1로 초기화
            i = 1
        temp = queue.pop(0) - i     # 맨 앞의 값에서 i만큼 빼주고
        if temp <= 0:               # 그 결과가 0이하가 되면
            queue.append(0)         # 끝에 0을 추가
            break                   # 종료
        queue.append(temp)          # 0이하가 아니라면 빼준 값을 뒤에 다시 추가
        i += 1                      # 빼주는 i값은 1 증가

    print(f'#{test_case}', end= ' ')
    print(*queue)
```

---

## 회전 (Queue)

<img width="897" alt="aps_172" src="https://user-images.githubusercontent.com/86648892/187035371-54b2cb33-686a-43e6-a57b-e8cdc5494373.png">

<img width="905" alt="aps_173" src="https://user-images.githubusercontent.com/86648892/187035377-6627077e-8e89-495a-9362-59888a558a69.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())        # N은 숫자 개수, M은 작업 횟수
    queue = list(map(int, input().split()))   # 수열

    # 맨 앞 숫자 맨 뒤로 보내기 M번 수행
    for _ in range(M):
        temp = queue.pop(0)
        queue.append(temp)

    # 수열 맨 앞 숫자 반환
    ans = queue.pop(0)
    print(f'#{test_case} {ans}')
```

---

## 피자 굽기 (Queue)

<img width="911" alt="aps_174" src="https://user-images.githubusercontent.com/86648892/187035439-e6203b60-ac43-427e-8ecf-2323ba1de40d.png">

<img width="918" alt="aps_175" src="https://user-images.githubusercontent.com/86648892/187035446-4301a8f9-36a7-4376-b85c-2cbadcc2f451.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())        # N은 화덕의 크기(큐에 들어갈 수 있는 원소의 수) # M은 피자의 개수
    arr = list(map(int, input().split()))
    pizza_number = [i for i in range(1, M+1)]
    pizzas = list(map(list, zip(arr, pizza_number)))   # pizzas[0]은 치즈량, pizzas[1]은 피자번호

    # 초기 화덕 설정
    queue = []
    for i in range(N):
        queue.append(pizzas.pop(0))
    # 피자가 다 떨어질 때까지
    while queue:
        pizza = queue.pop(0)                # 1번 위치에서 피자를 꺼내보고

        if pizza[0]//2 > 0:                 # 치즈를 반으로 나누어도 남아있다면
            pizza[0] = pizza[0]//2          # 치즈를 나눠주고
            queue.append(pizza)             # 5번 위치로 이동

        if len(queue) < N:                  # 화덕에 피자가 꽉 차있지 않다면
            if pizzas:                      # 그리고 새로 넣어줄 피자가 있다면
                new_pizza = pizzas.pop(0)   # 대기 중인 피자 중 가장 앞에 있는 피자를
                queue.append(new_pizza)     # 화덕에 추가

    print(f'#{test_case} {pizza[1]}')
```

---

## 노드의 거리 (BFS)

<img width="899" alt="aps_176" src="https://user-images.githubusercontent.com/86648892/187035547-9c65c88c-235e-4b8b-b0ea-52bcdf698e8f.png">

<img width="912" alt="aps_177" src="https://user-images.githubusercontent.com/86648892/187035549-259dbef0-b683-4bc5-a0a3-5df9f1e190b4.png">

```python
def bfs(s, e):  # s는 출발점 e는 목표지점
    # [1] queue, visited 초기화
    queue = []
    visited = [0]*(V+1)

    # [2] 초기데이터 삽입 및 visited 표시
    queue.append(s)
    visited[s] = 1

    while queue:                            # queue에 데이터가 있는동안 반복
        s = queue.pop(0)                    # 업데이트된 지점 확인

        if s == e:                          # 만약 해당 지점이 목표지점이라면 (도착한 경로가 있다면)
            return visited[s]-1             # 거리는 해당 지점의 visited값 -1
        
        # [3] 아직 목표에 도착하지 않았다면, 미방문 및 인접 노드로 이동
        for nxt in range(1, V+1):
            if nxt in adjList[s] and not visited[nxt]:
                queue.append(nxt)
                visited[nxt] = visited[s]+1 # 거리에 따라 visited 값을 grouping (목표 지점에 도달할 시 visited값에 -1한 값을 반환하면 거리를 반환한 것)
    
    # 목표 지점까지의 경로가 없다면 0 반환
    return 0

T = int(input())
for test_case in range(1, T+1):
    V, E = map(int, input().split())
    adjList = [[] for _ in range(V+1)]
    for _ in range(E):
        s, e = map(int, input().split())
        adjList[s].append(e)
        adjList[e].append(s)
    s, e = map(int, input().split())

    ans = bfs(s, e)
    print(f'#{test_case} {ans}')

# 교수님 풀이
# 나는 visited 값을 하나씩 올려줘서 거리를 구하는데 활용함
# 교수님은 따로 s와 더불어 distance를 뜻하는 d 변수를 따로 만들어 d를 1씩 증가시킴
'''
def bfs(S, G):
    visited = [0]*(V+1)
    q = []

    # q에 시작노드번호, 시작점으로부터의 거리
    q.append((S, 0))
    visited[S]=1

    while q:
        c, d = q.pop(0)    # 현재 노드번호(cur)
        if c == G:          # 목적지인 경우 거리(d) 리턴
            return d

        for e in adjL[c]:   # c와 연결된 노드 순서대로 체크
            if not visited[e]:
                q.append((e, d+1))  # 현재노드까지의 거리 + 1
                visited[e]=1

    # G가 연결된 노드가 아님
    return 0

# T = 10
T = int(input())
for test_case in range(1, T + 1):
    V, E = map(int, input().split())
    adjL = [[] for _ in range(V+1)]
    for _ in range(E):
        s, e = map(int, input().split())
        adjL[s].append(e)
        adjL[e].append(s)
    S, G = map(int, input().split())

    ans = bfs(S, G)

    print(f'#{test_case} {ans}')
'''
```

---

## 미로의 거리 (BFS)

<img width="889" alt="aps_178" src="https://user-images.githubusercontent.com/86648892/187035628-52e42937-5e8d-4a27-8a89-419d57455952.png">

<img width="913" alt="aps_179" src="https://user-images.githubusercontent.com/86648892/187035630-940fb870-6cc3-4b81-99da-6bce67061267.png">

```python
def bfs(si, sj, ei, ej, N):
    queue = []
    visited = [[0]*N for _ in range(N)]
    # 시작점
    queue.append((si, sj))
    visited[si][sj] = 1
    # 모두 순회할동안 타겟을 찾으면 거리 반환 그렇지 않으면 0 반환
    while queue:
        ci, cj = queue.pop(0)

        # 도착한다면
        if ci == ei and cj == ej:
            return visited[ci][cj]-2 # 출발점과 도착점을 뺀 칸 수 반환
        
        # 4방향 탐색
        for di, dj in ((-1,0),(1,0),(0,-1),(0,1)):
            ni, nj = ci+di, cj+dj
            # 범위 내, 벽이 아니고, 미방문지라면
            if 0<=ni<N and 0<=nj<N and maze[ni][nj]!=1 and visited[ni][nj]==0:
                queue.append((ni, nj))
                visited[ni][nj] = visited[ci][cj] + 1   # 다음 좌표는 현재 좌표보다 이동에 있어서 한 칸 더 갔다는 의미로 visited 값을 1씩 증가 (나중에 목표지점까지 갔을 때의 거리 구할 때 사용)

    # 경로가 없다면 0 반환
    return 0

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    maze = [list(map(int, input())) for _ in range(N)]

    # 시작점, 도착점 찾기
    for i in range(N):
        for j in range(N):
            if maze[i][j] == 2:
                si, sj = i, j
            elif maze[i][j] == 3:
                ei, ej = i, j

    ans = bfs(si, sj, ei, ej, N)
    print(f'#{test_case} {ans}')

# 교수님 풀이
# visited 값을 올리는 대신 거리를 의미하는 d 변수를 생성하여 1씩 증가
'''
def bfs(si,sj,ei,ej):
    visited = [[0]*N for _ in range(N)]
    q = []

    visited[si][sj]=1
    q.append((si,sj,0))

    while q:
        ci,cj,d = q.pop(0)
        if ci==ei and cj==ej:
            return d-1

        # 4방향, 범위내, 안가본, 벽이 아니면.. 방문
        for di,dj in ((-1,0),(1,0),(0,-1),(0,1)):
            ni,nj = ci+di, cj+dj
            if 0<=ni<N and 0<=nj<N and not visited[ni][nj] and arr[ni][nj]!='1':
                visited[ni][nj]=1
                q.append((ni,nj,d+1))

    return 0


# T = 10
T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [input() for _ in range(N)] # '2'
    for i in range(N):
        for j in range(N):
            if arr[i][j]=='2':
                si,sj = i,j
            elif arr[i][j]=='3':
                ei,ej = i,j

    ans = bfs(si,sj,ei,ej)

    print(f'#{test_case} {ans}')
'''
```

---

## 미로1 (BFS)

<img width="899" alt="aps_180" src="https://user-images.githubusercontent.com/86648892/187035791-c752065f-e8a5-4328-8b5b-3334d63dcaf8.png">

<img width="892" alt="aps_181" src="https://user-images.githubusercontent.com/86648892/187035792-0a0369aa-d7bf-410a-b706-6530680b44fc.png">

<img width="898" alt="aps_182" src="https://user-images.githubusercontent.com/86648892/187035794-b5dcce24-4d0d-46d3-93f5-2b4e31a3f488.png">

<img width="913" alt="aps_183" src="https://user-images.githubusercontent.com/86648892/187035795-337eedd4-f7d9-45b4-a907-a0380c60ced7.png">

<img width="904" alt="aps_184" src="https://user-images.githubusercontent.com/86648892/187035798-e0645fa7-fbda-4a1a-8d79-bd6bd4336009.png">

<img width="901" alt="aps_185" src="https://user-images.githubusercontent.com/86648892/187035799-03add7d1-4f29-4869-bd3e-6b21cb77de1d.png">

```python
def bfs(si, sj, ei, ej, N):
    # 큐 생성, visited 배열 생성
    queue = []
    visited = [[0]*N for _ in range(N)]

    # 시작점 작업
    queue.append((si, sj))
    visited[si][sj] = 1     # 방문표시

    # 갈 수 있는 점을 모두 돌 동안
    while queue:
        # 현재 이동한 좌표
        ci, cj = queue.pop(0)

        # 목표지점에 도달했다면
        if ci==ei and cj==ej:
            return 1
        
        # 4방향 탐색
        for di, dj in ((-1,0),(1,0),(0,-1),(0,1)):
            ni, nj = ci+di, cj+dj
            # 범위 내, 벽이 아닌, 미방문지라면
            if 0<=ni<N and 0<=nj<N and maze[ni][nj]!=1 and visited[ni][nj]==0:
                queue.append((ni, nj))
                visited[ni][nj] = 1     # 단순 방문표시

    # 목표지점에 도달하지 못했다면
    return 0

T = 10
for test_case in range(1, T+1):
    _ = int(input())
    N = 16
    maze = [list(map(int, input())) for _ in range(N)]

    # 시작점, 끝점 찾기
    for i in range(N):
        for j in range(N):
            if maze[i][j] == 2:
                si, sj = i, j
            elif maze[i][j] == 3:
                ei, ej = i, j

    ans = bfs(si, sj, ei, ej, N)
    print(f'#{test_case} {ans}')
```

---

## DFS / BFS 경로 기본 유형 정리
1. 탐색 (빠짐없이, 중복없이)
- DFS
- BFS
2. 최단거리
- DFS
- BFS
3. 경로의 수
- DFS
4. 확산 (출발점이 여러 곳)
- BFS

---

## DFS 기본구현

```python
# 기본적인 DFS를 통한 전체 탐색 구현

# A~G -> 0~6

adjList = [[1, 2],      # 0
            [0, 3, 4],  # 1
            [0, 4],     # 2
            [1, 5],     # 3
            [1, 2, 5],  # 4
            [3, 4, 6],  # 5
            [5]]        # 6

N = 7
visited = [0]*N     # visited 생성
stack = [0]*N       # stack 생성 (이전 탐색 지점)

# v는 시작지점 N은 정점개수
def dfs(v, N):
    top = -1            # stack top 초기화
    print(v)            # 방문해서 할 일
    visited[v] = 1      # A~G 중 시작점 방문 표시
    while True:
        for w in adjList[v]:        # 시작점의 인접 정점 검사
            if visited[w] == 0:     # 아직 탐색하지 않은 곳이라면 탐색
                top += 1            # top 인덱스 추가
                stack[top] = v      # 이전 지점인 v를 스택에 모아놓음
                v = w               # 현재 위치를 w로 변경
                print(v)            # 방문해서 할 일
                visited[w] = 1      # 탐색했으므로 1로 변경
                break
        else:
            if top != -1:           # 스택이 비어있지 않은 경우
                v = stack[top]      # pop
                top -= 1
            else:                   # 스택이 비어있으면
                break               # while 종료

dfs(1, N)

'''
# 2

# 인접원소 리스트를 input으로 받아 DFS를 통한 전체 탐색

0번부터 N번까지, E개의 간선
6 8
0 1
0 2
1 3
1 4
2 4
3 5
4 5
5 6

# input 받기
V, E = map(int, input().split())
N = V+1

# 인접원소 리스트 생성
adjList = [[] for _ in range(N)]
for _ in range(E):
    a, b = map(int, input().split())
    adjList[a].append(b)
    adjList[b].append(a)

visited = [0]*N     # visited 생성
stack = [0]*N       # stack 생성 (이전 탐색 지점)

# v는 시작지점 N은 정점개수
def dfs(v, N):
    top = -1            # stack top 초기화
    print(v)            # 방문해서 할 일
    visited[v] = 1      # A~G 중 시작점 방문 표시
    while True:
        for w in adjList[v]:        # 시작점의 인접 정점 검사
            if visited[w] == 0:     # 아직 탐색하지 않은 곳이라면 탐색
                top += 1            # top 인덱스 추가
                stack[top] = v      # 이전 지점인 v를 스택에 모아놓음
                v = w               # 현재 위치를 w로 변경
                print(v)            # 방문해서 할 일
                visited[w] = 1      # 탐색했으므로 1로 변경
                break
        else:
            if top != -1:           # 스택이 비어있지 않은 경우
                v = stack[top]      # pop
                top -= 1
            else:                   # 스택이 비어있으면
                break               # while 종료

dfs(1, N)

입력

6 8
0 1
0 2
1 3
1 4
2 4
3 5
4 5
5 6

출력

1
0
2
4
5
3
6
'''

'''
# 3

# 재귀함수를 통한 DFS 구현

0번부터 N번까지, E개의 간선
6 8
0 1
0 2
1 3
1 4
2 4
3 5
4 5
5 6

# input 받기
V, E = map(int, input().split())
N = V+1

# 인접원소 리스트 생성
adjList = [[] for _ in range(N)]
for _ in range(E):
    a, b = map(int, input().split())
    adjList[a].append(b)
    adjList[b].append(a)

visited = [0]*N     # visited 생성
stack = [0]*N       # stack 생성 (이전 탐색 지점)

# v는 시작지점 N은 정점개수
def dfs(v):
    print(v)                    # 방문해서 할 일
    visited[v] = 1
    for w in adjList[v]:
        if visited[w] == 0:     # 방문하지 않은 곳이라면 이동
            dfs(w)

dfs(1)

입력

6 8
0 1
0 2
1 3
1 4
2 4
3 5
4 5
5 6

출력

1
0
2
4
5
3
6
'''
```

---

## BFS 기본구현

```python
# 탐색하는 순서 찍기
def bfs(v, N):                          # v는 시작 노드, N은 마지막 노드
    visited = [0]*(V+1)                 # visited 생성 (거리가 같은 개수를 세야되는 등의 경우는 visited 배열을 밖에 만드는 것이 좋음)
    queue = []                          # 큐 생성

    queue.append(v)                     # 시작점 enQueue()
    visited[v] = 1                      # 시작점 방문표시
    ans.append(v)                       # 경로에 추가

    while queue:                        # 큐가 비어있지 않으면
        v = queue.pop(0)                # deQueue()
        for w in adjList[v]:            # 인접한 원소에 대하여
            if visited[w] == 0:         # 미방문지라면
                queue.append(w)         # enQueue()
                visited[w] = visited[v]+1   # 방문표시
                ans.append(w)           # 경로에 추가
T = int(input())
for test_case in range(1, T+1):
    # 1번부터 V번까지, E개의 간선
    V, E = map(int, input().split())
    # 인접리스트 생성
    adjList = [[] for _ in range(V+1)]
    # 양방향 간선에 대한 인접 원소값 추가
    for _ in range(E):
        a, b = map(int, input().split())
        adjList[a].append(b)
        adjList[b].append(a)
    ans = []
    bfs(1, V)
    print(f'#{test_case}', *ans)
```

---

## DFS 미로 경로의 거리

```python
# DFS의 최단경로
# 전제조건: 모든 경로를 돌아봐야함 (BFS는 거리에 따라 grouping이 되어있어 도착지점을 발견하면 발견한 당시의 거리를 반환하면 되지만 DFS는 그러한 grouping이 없음)
# 재귀로 구현

# s는 이전까지 지나온 칸 수, 다음 번 칸에서 호출할 때는 s+1을 넣어서 호출하면 됨
def dfs(i, j, s, N):
    global min_distance
    if maze[i][j] == 3:             # [1] 종료 조건
        if min_distance > s+1:      # 출발점, 도착점 포함한 거리 (s는 이전까지 지나온 칸 수로 도착점일 때 이전까지 지나온 거리에 +1)
            min_distance = s+1
        return
    # 도착지점이 아니라면
    # [2] 작업
    else:
        visited[i][j] = 1   # 현재 방문 표시
        for di, dj in ((-1,0), (1,0), (0,-1), (0,1)):   # 4방향 탐색
            ni, nj = i+di, j+dj
            # 갈 곳이 범위 내, 벽이 아니고, 미방문지라면
            if 0<=ni<N and 0<=nj<N and maze[ni][nj] != 1 and visited[ni][nj]==0:
                # 다음은 너를 기준으로 이동해
                dfs(ni, nj, s+1, N) # [3] 하부호출 (다음 좌표에서는 이전까지 온 칸 수에서 한 칸 더 간 것이므로)
        visited[i][j] = 0   # 다른 호출에 대해서 방문표시가 되어있으면 안되니 방문표시 초기화 # 잊지 말 것!!!
        return

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    maze = [list(map(int, input())) for _ in range(N)]
    visited = [[0]*N for _ in range(N)]
    min_distance = N*N      # 거리의 최대값으로 초기화

    # 시작점 찾기
    si, sj = -1, -1
    for i in range(N):
        for j in range(N):
            if maze[i][j] == 2:
                si, sj = i, j
                break
        if si != -1:
            break

    dfs(si, sj, 0, N)       # 시작점일 때는 아직 지나온 칸이 없으므로 0

    # 도착하지 못하는 경우 위 함수에서 min_distance가 변하지 않고 초기값이 유지되므로 -1로 변경
    if min_distance == N*N:
        min_distance = -1

    print(f'#{test_case} {min_distance}')

'''
입력
3
5
11111
12001
10101
13001
11111
5
11111
12131
10111
10001
11111
9
111111111
120000001
101110101
100000101
111110101
101000101
101011101
100000031
111111111

출력
#1 3
#2 -1
#3 13
'''
```

---

## BFS 미로 경로의 거리

```python
def bfs(si, sj, N):
    visited = [[0]*N for _ in range(N)]
    queue = []
    # 시작점
    queue.append((si, sj))
    visited[si][sj] = 1
    # 모두 순회할동안 타겟을 찾으면 1 반환 그렇지 않다면 0 반환
    while queue:
        ci, cj = queue.pop(0)
        # 목표작업 수행
        if maze[ci][cj] == 3:       # 도착좌표에 도착했다면
            #return 1               # 1 반환하고 종료 (경로 있음)
            return visited[ci][cj]  # 경로 거리 반환 후 종료
        for di, dj in ((-1,0), (1,0), (0,-1), (0,1)):   # 4방향 탐색
            ni, nj = ci+di, cj+dj
            # 범위 내, 벽이 아니고, 미방문지라면
            if 0<=ni<N and 0<=nj<N and maze[ni][nj]!=1 and visited[ni][nj]==0:
                queue.append((ni, nj))
                visited[ni][nj] = visited[ci][cj] + 1
    #return 0                       # 0 반환하고 종료 (경로 없음)
    return -1                       # 경로 거리 없을 때 -1 반환

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    maze = [list(map(int, input())) for _ in range(N)]
    
    # 시작점 찾기
    si, sj = -1, -1
    for i in range(N):
        for j in range(N):
            if maze[i][j] == 2:
                si, sj = i, j
                break
        if si != -1:
            break
    
    ans = bfs(si, sj, N)
    print(f'#{test_case} {ans}')

'''
입력
3
5
11111
12001
10101
13001
11111
5
11111
12131
10111
10001
11111
9
111111111
120000001
101110101
100000101
111110101
101000101
101011101
100000031
111111111

출력
#1 3
#2 -1
#3 13
'''
```

---

## DFS 미로 경로의 개수

```python
# DFS의 최단경로
# 전제조건: 모든 경로를 돌아봐야함 (BFS는 거리에 따라 grouping이 되어있어 도착지점을 발견하면 발견한 당시의 거리를 반환하면 되지만 DFS는 그러한 grouping이 없음)
# 재귀로 구현
def dfs(i, j, N):
    global cnt
    if maze[i][j] == 3:     # [1] 종료 조건
        cnt += 1          # 목표에 도착하는 경로의 개수만큼 cnt를 올려줄 것임
        return
    # 도착지점이 아니라면
    # [2] 작업
    else:
        visited[i][j] = 1   # 현재 방문 표시
        for di, dj in ((-1,0), (1,0), (0,-1), (0,1)):   # 4방향 탐색
            ni, nj = i+di, j+dj
            # 갈 곳이 범위 내, 벽이 아니고, 미방문지라면
            if 0<=ni<N and 0<=nj<N and maze[ni][nj] != 1 and visited[ni][nj]==0:
                # 다음은 너를 기준으로 이동해
                dfs(ni, nj, N) # [3] 하부호출
        visited[i][j] = 0   # 다른 호출에 대해서 방문표시가 되어있으면 안되니 방문표시 초기화 # 잊지 말 것!!!
        return

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    maze = [list(map(int, input())) for _ in range(N)]
    visited = [[0]*N for _ in range(N)]
    cnt = 0

    # 시작점 찾기
    si, sj = -1, -1
    for i in range(N):
        for j in range(N):
            if maze[i][j] == 2:
                si, sj = i, j
                break
        if si != -1:
            break

    dfs(si, sj, N)
    print(f'#{test_case} {cnt}')

'''
입력
3
5
11111
12001
10101
13001
11111
5
11111
12131
10111
10001
11111
9
111111111
120000001
101110101
100000101
111110101
101000101
101011101
100000031
111111111

출력
#1 2
#2 0
#3 4
'''
```

---

## BFS 여러개의 출발점과 거리 (확산)

```python
'''
2가 바이러스가 있는 곳이라 가정하고, 여기서 동일한 속도 1초에 한 칸씩 4방향으로 확산된다고 하자
모든 칸에 냄새가 퍼지는데 시간이 얼마나 걸리는가?
'''

def bfs(N):     # N은 크기
    visited = [[0]*N for _ in range(N)]
    queue = []
    maxV = 0    # visited 값 중 최대값 담기용

    # 여러 개의 출발점 찾기
    # 출발점 찾을 때마다 [1] enQueue [2] 방문표시
    for i in range(N):
        for j in range(N):
            if maze[i][j] == 2:
                queue.append((i, j))
                visited[i][j] = 1

    while queue:
        i, j = queue.pop(0)

        for di, dj in ((-1,0), (1,0), (0,-1), (0,1)):   # 4방향 탐색
            ni, nj = i+di, j+dj
            # 범위 내, 벽이 아니고, 미방문지라면
            if 0<=ni<N and 0<=nj<N and maze[ni][nj]!=1 and visited[ni][nj]==0:
                queue.append((ni, nj))
                visited[ni][nj] = visited[i][j] + 1
                # 해당 visited 값이 가장 크다면(가장 긴 경로 길이라면) 최대값 갱신
                if visited[ni][nj] > maxV:
                    maxV = visited[ni][nj]
    return maxV

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    maze = [list(map(int, input())) for _ in range(N)]
    ans = bfs(N)-1 # 출발점의 visited값이 1이고 거기서부터 1씩 증가하는 것이므로, 확산까지 몇 초 걸리냐는 -1
    print(f'#{test_case} {ans}')

'''
입력
3
5
11111
12001
10101
12001
11111
5
11111
12121
10111
10001
11111
9
111111111
120000001
101110101
100002101
111110101
121000101
101011101
100000021
111111111

출력
#1 3
#2 4
#3 5
'''
```

---

## 숫자 배열 회전 (IM)

<img width="909" alt="aps_186" src="https://user-images.githubusercontent.com/86648892/187036367-f68dabde-76bf-46ed-85df-5136f96618bf.png">

<img width="900" alt="aps_187" src="https://user-images.githubusercontent.com/86648892/187036374-4167417a-ed94-4a41-8292-b4c4e080de82.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    arr_90 = [[0]*N for _ in range(N)]
    arr_180 = [[0]*N for _ in range(N)]
    arr_270 = [[0]*N for _ in range(N)]

    # 좌표 인덱스 가지고 놀기 (90도, 180도, 270도 회전 배열 생성)
    # 목적지 기준 좌표 규칙성 찾기
    for i in range(N):
        for j in range(N):
            arr_90[i][j] = arr[N-1-j][i]
            arr_180[i][j] = arr[N-1-i][N-1-j]
            arr_270[i][j] = arr[j][N-1-i]

    # 해당 2차원배열 출력 연습 (90도, 180도, 270도 배열 객체 간만 공백 생성)
    print(f'#{test_case}')
    for i in range(N):
        for a in range(N):
            print(arr_90[i][a], end='')
        print(end=' ')
        for b in range(N):
            print(arr_180[i][b], end='')
        print(end=' ')
        for c in range(N):
            print(arr_270[i][c], end='')
        print()

# 교수님 풀이
# rotate를 통해 구현
# 출력시 join 사용
'''
def rotate(arr):
    arrR = [[0]*N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            arrR[i][j] = arr[N-1-j][i]
    return arrR

# T = 10
T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]

    arr1 = rotate(arr)
    arr2 = rotate(arr1)
    arr3 = rotate(arr2)

    print(f'#{test_case}')
    for a,b,c in zip(arr1, arr2, arr3):
        print(f'{"".join(map(str,a))} {"".join(map(str,b))} {"".join(map(str,c))}')
'''
```

---

## 진기의 최고급 붕어빵 (IM)

<img width="900" alt="aps_188" src="https://user-images.githubusercontent.com/86648892/187036456-3d67a492-ec74-43b0-8022-c8805c2de953.png">

<img width="919" alt="aps_189" src="https://user-images.githubusercontent.com/86648892/187036459-eed9cf4b-1603-4625-a30c-1b638eda608e.png">

<img width="923" alt="aps_190" src="https://user-images.githubusercontent.com/86648892/187036460-1fd66611-12a4-4ae1-abda-38439f4af3c5.png">

```python
# 388 ms
# T = 10
T = int(input())
for test_case in range(1, T+1):
    N, M, K = map(int, input().split())
    lst = list(map(int, input().split()))

    ans = 'Possible'
    cnt = 0 # 도착한 사람 수
    lst.sort()

    for t in lst:
        cnt += 1              # 사람 한 명 추가
        # M초에 K개 만들 시 M//M이 하나의 세션이고 이 하나의 세션이 있어야 K개가 만들어진다는 뜻
        # 즉, t초에 방문할 시 t // M을 해보면 몇 개의 세션이 지났는지 알 수 있음
        # 가령 2초에 2개씩 만드는 경우, 1초에 방문하면 1//2 = 0으로 아직 완료된 세션이 없고, 고로 붕어빵은 0개다
        if cnt > (t//M)*K:    # 현재 도착한 사람 수보다 붕어빵 개수가 적다면: Impossible
            ans = 'Impossible'
            break

    print(f'#{test_case} {ans}')

'''
# 나의 풀이
# 686 ms
T = int(input())
for test_case in range(1, T+1):
    N, M, K = map(int, input().split())     # N명의 손님, M초가 지나면 K개의 붕어빵 생성
    arr = list(map(int, input().split()))   # 손님 방문 시간 리스트
    t = 0
    ans = 'Possible'
    # 가장 나중에 방문하는 시간
    for i in arr:
        if i > t:
            t = i
    cnts = [0]*(t+1)                        # 0초~t초당 붕어빵 개수

    for i in range(t+1):
        if i != 0 and i % M == 0:
            cnts[i] = cnts[i-1] + K
        else:                               # 이 코드의 위험성 [1]: i=0일 경우 cnts[-1]으로 접근하여 0을 받도록 돌아가긴 하지만 이쁜 구조는 아님
            cnts[i] = cnts[i-1]

        if i in arr:
            if cnts[i] == 0:
                ans = 'Impossible'
                break
            else:
                cnts[i] -= 1                # 이 코드의 위험성 [2]: 해당 초 수의 사람이 1명이라 가정한 경우임 / 만약 테스트케이스에 같은 초 수에 2명 이상이 있다고 한다면 -1이 아니라 해당 초 수의 사람 수도 따로 구해 해당 값을 빼줘야 함

    print(f'#{test_case} {ans}')
'''
```

---

## 오목 판정 (IM)

<img width="905" alt="aps_191" src="https://user-images.githubusercontent.com/86648892/187036530-c7468a9c-9893-45c0-927f-9826442bd673.png">

<img width="906" alt="aps_192" src="https://user-images.githubusercontent.com/86648892/187036532-63e6e01f-3435-4321-903f-c0b6e3e0650a.png">

```python
# 수행하는 작업이 무엇인지 인지하고 for문 순회

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    arr = [list(input()) for _ in range(N)]
    ans = 'NO'
    cnt = 1     # 시작좌표 중 오목돌이 있는 곳만 판별할 것이므로 카운트를 1로 시작

    # 십자가 오목 판정
    for si in range(N):
        for sj in range(N):                                             # 기준좌표 si, sj
            if arr[si][sj] == 'o':                                      # 해당좌표가 오목돌이라면
                for di, dj in ((0,-1), (0,1), (-1,0), (1,0)):           # 각 방향 탐색
                    for mul in range(1, 5):                             # 각 방향에서 4칸까지 탐색
                        ni, nj = si+di*mul, sj+dj*mul                   # 해당 칸이
                        if 0<=ni<N and 0<=nj<N and arr[ni][nj] == 'o':  # 범위 내, 오목돌이라면
                            cnt += 1                                    # 해당 라인 오목돌 수 +1
                            if cnt == 5:                                # 오목돌이 해당 라인에 5개라면 오목 있음
                                ans = 'YES'                             # 그러므로 YES
                    cnt = 1

    # 대각선 판정
    for si in range(N):
        for sj in range(N):
            if arr[si][sj] == 'o':
                for di, dj in ((-1,1), (1,1), (1,-1), (-1,-1)):
                    for mul in range(1, 5):
                        ni, nj = si+di*mul, sj+dj*mul
                        if 0<=ni<N and 0<=nj<N and arr[ni][nj] == 'o':
                            cnt += 1
                            if cnt == 5:
                                ans = 'YES'
                    cnt = 1

    print(f'#{test_case} {ans}')
```

---

## 두 개의 숫자열 (IM)

<img width="928" alt="aps_193" src="https://user-images.githubusercontent.com/86648892/187036621-536f60d2-4e05-4157-a9db-1665ec1f3f4a.png">

<img width="913" alt="aps_194" src="https://user-images.githubusercontent.com/86648892/187036623-2d0a1611-e672-4a31-b450-b0f640810c9f.png">

```python
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())
    lst1 = list(map(int, input().split()))
    lst2 = list(map(int, input().split()))
    ans = 0

    # 짧은 숫자열을 기준으로 start index를 옮겨가며 비교
    # lst1이 더 짧은 경우
    if N < M:
        # 모든 가능한 출발점에 대하여
        for s in range(M-N+1):
            sm = 0
            # 더 작은 숫자열의 길이만큼 수행
            for i in range(s, s+N):
                sm += lst1[i-s]*lst2[i]
            # 합 중 최댓값 업데이트
            if sm > ans:
                ans = sm

    # lst2가 더 짧은 경우
    elif N > M:
        for s in range(N-M+1):
            sm = 0
            for i in range(s, s+M):
                sm += lst1[i]*lst2[i-s]
            if sm > ans:
                ans = sm

    # 길이가 동일한 경우 (위아래 동일한 인덱스의 값들 곱해서 더해준 것이 유일한 값이자 최댓값)
    else:
        for i in range(N):
            ans += lst1[i]*lst2[i]

    print(f'#{test_case} {ans}')
```

---

## 영준이의 카드 카운팅 (IM)

<img width="917" alt="aps_195" src="https://user-images.githubusercontent.com/86648892/187036695-778ea4e1-8d29-41b3-829d-553b5669ed9d.png">

<img width="906" alt="aps_196" src="https://user-images.githubusercontent.com/86648892/187036700-5cc18852-28c3-4115-95a2-8cb7751274ce.png">

```python
# dictionary를 활용하여 문자를 통한 인덱스 접근
# 중복을 검사하기 위해 set 활용
# 리스트 내 일정범위 확인하기 위해 슬라이싱 활용

T = int(input())
for test_case in range(1, T+1):
    st = input()
    arr = [[] for _ in range(4)]            # 각각 S, D, H, C 카드를 담을 배열 생성
    dct = {'S': 0, 'D': 1, 'H': 2, 'C': 3}  # S, D, H, C 접근 후 인덱스 접근용 딕셔너리
    
    # 카드 번호 저장
    for i in range(0, len(st), 3):          # S, D, H, C는 문자열에서 3칸 간격으로 나옴
        num = int(st[i+1:i+3])              # S, D, H, C 위치(i) 뒤의 두 칸(i+1~i+2)은 해당 카드 번호
        arr[dct[st[i]]].append(num)         # 이 번호를 해당 카드 덱에 추가

    # 중복된 카드가 들어가있으면 에러 처리 (배열과 세트의 길이가 다르다면 중복된 것이 있는 것)
    # 중복된 것이 없다면 각각 더 필요한 카드 개수를 ans에 추가
    ans = []
    for lst in arr:
        if len(lst) != len(set(lst)):
            print(f'#{test_case} ERROR')
            break
        else:
            ans.append(13-len(lst))         # 더 필요한 카드 개수 추가
    else:
        print(f'#{test_case}', *ans)

# 나의 풀이
# 코드가 너무 길다
'''
T = int(input())
for test_case in range(1, T+1):
    lst = list(input())
    lst_s = []
    lst_d = []
    lst_h = []
    lst_c = []
    error = ''

    # 카드값 넣기
    for i in range(len(lst)):
        if lst[i] == 'S':
            if lst[i+1] == '0':
                if lst[i+2] in lst_s:
                    error = 'ERROR'
                    break
                else:
                    lst_s.append(lst[i+2])
            else:
                if lst[i+1]+lst[i+2] in lst_s:
                    error = 'ERROR'
                    break
                else:
                    lst_s.append(lst[i+1]+lst[i+2])

        elif lst[i] == 'D':
            if lst[i+1] == '0':
                if lst[i+2] in lst_d:
                    error = 'ERROR'
                    break
                else:
                    lst_d.append(lst[i+2])
            else:
                if lst[i+1]+lst[i+2] in lst_d:
                    error = 'ERROR'
                    break
                else:
                    lst_d.append(lst[i+1]+lst[i+2])

        elif lst[i] == 'H':
            if lst[i+1] == '0':
                if lst[i+2] in lst_h:
                    error = 'ERROR'
                    break
                else:
                    lst_h.append(lst[i+2])
            else:
                if lst[i+1]+lst[i+2] in lst_h:
                    error = 'ERROR'
                    break
                else:
                    lst_h.append(lst[i+1]+lst[i+2])

        elif lst[i] == 'C':
            if lst[i+1] == '0':
                if lst[i+2] in lst_c:
                    error = 'ERROR'
                    break
                else:
                    lst_c.append(lst[i+2])
            else:
                if lst[i+1]+lst[i+2] in lst_c:
                    error = 'ERROR'
                    break
                else:
                    lst_c.append(lst[i+1]+lst[i+2])

    # 중복이 있다면 ERROR 출력, 없다면 각각 부족한 카드 수 출력
    if error:
        print(f'#{test_case} {error}')
    else:
        print(f'#{test_case} {13-len(lst_s)} {13-len(lst_d)} {13-len(lst_h)} {13-len(lst_c)}')
'''
```

---

## 달란트2 (IM)

<img width="906" alt="aps_197" src="https://user-images.githubusercontent.com/86648892/187036780-7b41ead0-e4f8-4a4d-bd9b-cc2184fc97dd.png">

<img width="887" alt="aps_198" src="https://user-images.githubusercontent.com/86648892/187036785-3844e033-ddb2-4ce6-a8b5-298814a40170.png">

<img width="909" alt="aps_199" src="https://user-images.githubusercontent.com/86648892/187036789-83aa70e4-a87c-4024-880c-352cdc0cb4be.png">

```python
# 아이디어성 문제
# 묶음을 나누어 최대의 곱을 구하려면 묶음의 숫자들의 차이가 가장 적게 나누어 곱해주는 것이라는 아이디어
# ex) 10 -> 3x3x4, 11 -> 3x4x4, 13 -> 4x4x5
T = int(input())
for test_case in range(1, T+1):
    N, P = map(int, input().split())    # N은 달란트 개수 M은 묶음 개수
    ans = 1
    for i in range(P):
        ans *= N//(P-i)
        N -= N//(P-i)

    print(f'#{test_case} {ans}')

'''
# 교수님 풀이
# 묶음 수 만큼 균등한 숫자 배분 후 -> 남은 숫자들을 나머지 연산자들을 활용하여 추가로 균등하게 채우기
T = int(input())
for test_case in range(1, T+1):
    N, P = map(int, input().split())
    lst = [N // P] * P      # 모두 같은 값으로 초기화 (균등배분)

    # 균등배분 후 남은 숫자를 가능한만큼 균등하게 배분
    for i in range(N % P):
        lst[i] += 1

    # 이렇게 생성된 묶음이 곱의 최댓값을 만듬
    ans = 1
    for n in lst:
        ans *= n
    
    print(f'#{test_case} {ans}')
'''
```

---

## 2차원 배열 영역 나누기

```python
# arr 범위 나누는 간단한 예
# 아래 4가지 조건들에 and나 or를 사용하여 영역 세분화 지정 가능

N = 5
arr = [[0]*N for _ in range(N)]
for i in range(N):
    for j in range(N):
        # 좌상단 -> 우하단 대각선 오른쪽 영역에 1 채우기
        #if i < j:
            #arr[i][j] = 1
        # 좌상단 -> 우하단 대각선 왼쪽 영역에 2 채우기
        #if i > j:
            #arr[i][j] = 2
        # 좌하단 -> 우상단 대각선 왼쪽 영역에 1 채우기
        if i < N-1-j:
            arr[i][j] = 1
        # 좌하단 -> 우상단 대각선 오른쪽 영역에 2 채우기
        if i > N-1-j:
            arr[i][j] = 2
```

---

## 가위바위보 (lookup table 간단한 예시)

```python
# 0, 1, 2: 가위, 바위 보
i = 0
cpu = 2

if i == cpu:
    res = 0
elif i == (cpu+1)%3:
    res = 1
else:
    res = -1

# lookup table 활용
tbl = [[0, -1, 1][1, 0, -1][-1, 1, 0]]
res = tbl[i][cpu]
```

---

## 고대유적

```python
'''
땅속의 구조물을 촬영할 수 있는 특수 위성 카메라에 땅속에 묻힌 고대 구조물이 발견되었다.
구조물은 폭 1m, 길이 2m 이상의 직선 형태로 서로 평행 또는 직각으로만 자리하고 있으며, 1mx1m의 해상도의 사진데이터에 구조물이 있는 자리는 1로 나타난다.

사진의 해상도는 NxM이며, 구조물이 있는 곳은 1, 빈 땅은 0으로 표시된다.
위 그림의 경우 가장 긴 구조물은 노란색으로 표시된 영역이며, 길이는 6이다.
교차하거나 만나는 것처럼 보이는 구조물은 서로 다른 깊이에 묻힌 것이므로 직선인 구조물만 고려하면 된다.

다음과 같은 경우는 길이가 3인 구조물 4개가 겹쳐 보이는 것이다.

평행한 모든 구조물은 서로 1m이상 떨어져 있고, 구조물의 최소 크기는 1x2m이다.
여러 구역의 사진 데이터가 주어질 때, 각 구역 별로 가장 긴 구조물의 길이를 찾는 프로그램을 만드시오.

입력
첫 줄에 사진 데이터의 개수, 다음 줄부터 사진 데이터 별로 첫 줄에 N과 M, 이후 N개의 줄에 M개씩의 데이터가 제공된다.
(3<=N, M<=100)

출력
#과 1번부터 시작하는 사진 번호, 빈칸과 가장 긴 구조물의 길이를 출력한다.

입력
3
3 3
0 1 0
0 1 0
0 1 0
3 3
0 1 0
1 1 1
0 0 0
8 8
1 0 0 0 0 0 1 0
1 0 1 1 1 0 1 0
1 0 0 0 0 0 1 0
0 0 0 1 0 0 1 0
0 0 0 1 0 0 1 0
0 1 1 0 0 0 1 0
0 0 0 0 0 0 0 0
0 0 0 0 1 1 1 1

출력
#1 3
#2 3
#3 6
'''
# test case 입력
T = int(input())
for test_case in range(1, T+1):
    # 입력값 받기
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 최대구간길이 초기화
    maxV = 0
    # 행 구간길이 검사
    for i in range(N):
        cnt = 0
        for j in range(M):
            if arr[i][j] == 1:
                cnt += 1
                if maxV < cnt:
                    maxV = cnt
            # 연속되지 않을 경우 구간길이 초기화
            else:
                cnt = 0
    # 열 구간 검사
    for i in range(M):
        cnt = 0
        for j in range(N):
            if arr[j][i] == 1:
                cnt += 1
                if maxV < cnt:
                    maxV = cnt
            else:
                cnt = 0
    print(f'#{test_case} {maxV}')
```

---

## 최대 행의 합
```python
'''
각 행의 합을 구하고 그 중 최대값을 출력하시오
3
1 2 3
4 5 6
7 8 9
'''
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

maxV = 0 # 최대 행의 합
for i in range(N):
    rs = 0 # 행의 합
    for j in range(N):
        rs += arr[i][j]
    if rs > maxV:
        maxV = rs
print(maxV)
```

---

## 대각선의 합

```python
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

# 좌측 상단에서 우측 하단 방향 대각선 합
# 어차피 대각선은 동일한 인덱스일 것
# 1
s1 = 0
for i in range(N):
    s1 += arr[i][i]

'''
# 2
s1 = 0
for i in range(N):
    for j in range(N):
        if i == j:
            s1 += arr[i][j]
'''

# 좌측 하단에서 우측 상단 방향 대각선 합
s2 = 0
for i in range(N):
    s2 += arr[i][N-1-i]

'''
두 대각선의 합?

1) 가로세로가 짝수일 때: 위의 s1과 s2를 더해줌
2) 가로세로가 홀수일 때: 위의 s1과 s2를 더해줌 + 정가운데에 겹치는 부분 하나 빼주기
'''
```

---

## 대각선의 합 (응용)

```python
# 좌측 상단에서 우측 하단으로 가는 대각선을 기준으로 오른쪽 영역, 왼쪽 영역 중 합이 더 큰 값은 얼마?
'''
3
1 2 3
4 5 6
7 8 9
'''
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

ls = 0 # 왼쪽 영역 합
rs = 0 # 오른쪽 영역 합

for i in range(N):
    for j in range(N):
        if i > j: # 왼쪽 영역이라면
            ls += arr[i][j]
        elif i < j: # 오른쪽 영역이라면
            rs += arr[i][j]
'''
# 또 다른 접근법
# 영역을 나누는 것이 아니라 rs는 가로방향으로 대각선 넘은 부분부터 쭉 더해주고, ls는 세로방향으로 대각선 넘은 부분부터 쭉 더해주는 접근
for i in range(N):
    for j in range(i+1, N):
        rs += arr[i][j]
        ls += arr[j][i]
'''
print(ls, rs)
```

---

## 사선의 합
```python
'''
3
1 2 3
4 5 6
7 8 9
'''
# 각 같은 사선상에 있는 원소들의 합을 구하고 최대값을 찾아보시오
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

# 사선을 일일이 순회하는 것이 아니라 가로 방향으로 차례로 순회하면서 해당하는 사선합에 넣어줄 것
# 사선의 개수는 2N-1

# 사선의 합들 초기화
s = [0]*(2*N-1)

# 사선의 합들 구하기
# 각 사선들은 i+j 값들이 같은 원소들
for i in range(N):
    for j in range(N):
        s[i+j] += arr[i][j]

print(s)
print(max(s))
```

---

## 마이쮸 (Queue)

```python
# 마이쮸를 받은 사람이 다시 줄을 서면 새로운 사람이 들어와서 새롭게 줄을 선다는 로직
p = 1   # 처음 줄 설 사람 번호
q = []  # queue 초기화
N = 20  # 초기 마이쮸 개수
M = 0   # 나눠준 개수

while M < N:                        # 마이쮸가 남아있다면
    input()                         # 자동 while 실행 방지
    q.append((p, 1, 0))             # 최초로 줄 서는 사람 추가 # (몇번째로 줄서는 사람인지, 해당 사람이 몇번쨰로 서고 있는지, 나눠주는 사탕수)
    print(q)
    v, c, candy = q.pop(0)          # (해당 사람 번호, 몇개 받아야되는지, 해당 사람에게 나눠준 누적 사탕 개수)
    print(f'큐에 있는 사람 수: {len(q)+1}, 받아갈 사탕 수: {c}, 나눠준 사탕 수: {M}')
    M += c                          # c만큼 주고 위에서 pop했으니 전체 나눠준 개수 업데이트
    q.append((v, c+1, candy+c))     # 마이쮸를 받고 다시 서는 사람
    p += 1                          # 처음 줄 서는 사람 번호
print(f'마지막 받은 사람: {v}')

# deque()를 사용하여 실행시간 줄이기
'''
from collections import deque
p = 1       # 처음 줄 설 사람 번호
q = deque() # queue 초기화
N = 1000    # 초기 마이쮸 개수
M = 0       # 나눠준 개수

while M < N:                        # 마이쮸가 남아있다면
    input()                         # 자동 while 실행 방지
    q.append((p, 1, 0))             # 최초로 줄 서는 사람 추가 # (몇번째로 줄서는 사람인지, 해당 사람이 몇번쨰로 서고 있는지, 나눠주는 사탕수)
    print(q)
    v, c, candy = q.popleft()       # (해당 사람 번호, 몇개 받아야되는지, 해당 사람에게 나눠준 누적 사탕 개수)
    print(f'큐에 있는 사람 수: {len(q)+1}, 받아갈 사탕 수: {c}, 나눠준 사탕 수: {M}')
    M += c
    q.append((v, c+1, candy+c))     # 마이쮸를 받고 다시 서는 사람
    p += 1                          # 처음 줄 서는 사람 번호
print(f'마지막 받은 사람: {v}')
'''
```

---

## 부분집합 백트래킹 구현

```python
# bit[i]는 A[i]의 포함여부
# 부분집합의 인덱스 0번 원소부터 시작
# 인덱스 0번 원소에서 출발 -> 아직 N이 아니네? -> 해당 0번 원소를 포함 / 비포함으로 나누어 각각 해당 경우로 다시 함수 실행
# 0번 원소가 포함된 경우에서 1번 원소가 포함 / 비포함으로 쪼개지고, 0번 원소가 포함되지 않은 경우에서 1번 원소가 포함 / 비포함으로 쪼개짐
# 이를 반복하여 N-1까지 갈 경우(끝 원소) 해당 원소에 대해 다시 포함 / 비포함으로 나누고
# 여기서 i+1을 하면 이제 i == N에 걸림
# 모든 부분집합의 케이스들에 대하여 i == N 이하의 항목이 실행됨

# 모든 부분집합 생성
def make_subsets(i, N):
    if i == N:
        for i in range(N):
            if bit[i]:
                print(A[i], end = ' ')
        print() # 줄바꿈용
    else:
        bit[i] = 1          # A[i]가 포함된 경우
        make_subsets(i+1, N)
        bit[i] = 0          # A[i]가 포함되지 않은 경우
        make_subsets(i+1, N)

# 부분집합 원소의 합이 10인 경우의 수 생성
def subset_sum(i, N):
    global ans
    if i == N:
        s = 0
        for i in range(N):
            if bit[i]:
                s += A[i]
        if s == 10:
            ans += 1
    else:
        bit[i] = 1
        subset_sum(i+1, N)
        bit[i] = 0
        subset_sum(i+1, N)

# 부분집합 원소의 합이 K인 경우의 수 생성
# 가지치지 않은 경우
# (cnt를 통해 가지치기 하지 않은 경우를 보자)
def subset_sum_k(i, N, s, K):
    global ans
    global cnt
    cnt += 1
    if i == N:                              # 모든 원소가 고려된 경우
        if s == K:                          # 부분집합의 합이 K라면
            ans += 1
    else:
        subset_sum_k(i+1, N, s+A[i], K)     # A[i]가 포함된 경우로 재귀
        subset_sum_k(i+1, N, s, K)          # A[i]가 포함되지 않은 경우로 재귀

# if문을 통해 가지치기를 구현한 경우
def subset_sum_k_backtracking(i, N, s, K):
    global ans
    global cnt
    cnt += 1
    if i == N:
        if s == K:
            ans += 1
    elif s > K:                     # 가지치기
        return                      # s가 K를 넘어가는 순간 더 이상 고려하지 않아도 되므로 중단
    else:
        subset_sum_k_backtracking(i+1, N, s+A[i], K)
        subset_sum_k_backtracking(i+1, N, s, K)

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
bit = [0]*10
#make_subsets(0, 10)
ans = 0
cnt = 0         # 가지치기 안했을 때와 했을 때 차이를 보기 위함
#subset_sum(0, 10)
#print(ans)     # 10
#subset_sum_k(0, 10, 0, 10)
#print(ans)     # 10
#print(cnt)     # 2047 (가지치기를 하지 않은 경우)
subset_sum_k_backtracking(0, 10, 0, 10)
print(ans)      # 10
print(cnt)      # 415 (가지치기를 한 경우)
```

---

## 순열생성 (재귀)

```python
# 순열 생성 함수
# i가 0일 경우 P[0]부터 시작하여
# 첫째 항(P[0])을 첫 항...마지막 항과 바꾼 경우에 대하여 (첫 항...마지막 항이 첫번째 자리를 차지하는 경우)
# 두번째 항을 두번째 항...마지막 항과 바꾼 경우에 대하여 (둘째 항...마지막 항이 두번째 자리를 차지하는 경우)
# ...
# 마지막 N-1째 항까지 위 작업을 수행한 뒤
# 완성된 모든 케이스들을 각각 출력
def permutation(i, N):
    if i == N:                          # [1] 종료조건 (순열완성)
        print(P)
    else:
        for j in range(i, N):           # [2] 단위작업
            P[i], P[j] = P[j], P[i]
            permutation(i+1, N)         # [3] 하부호출
            P[i], P[j] = P[j], P[i]     # [2] 단위작업 (원상복구)

P = [1, 2, 3, 4]
permutation(0, 4)
'''
[1, 2, 3, 4]
[1, 2, 4, 3]
[1, 3, 2, 4]
[1, 3, 4, 2]
[1, 4, 3, 2]
[1, 4, 2, 3]
[2, 1, 3, 4]
[2, 1, 4, 3]
[2, 3, 1, 4]
[2, 3, 4, 1]
[2, 4, 3, 1]
[2, 4, 1, 3]
[3, 2, 1, 4]
[3, 2, 4, 1]
[3, 1, 2, 4]
[3, 1, 4, 2]
[3, 4, 1, 2]
[3, 4, 2, 1]
[4, 2, 3, 1]
[4, 2, 1, 3]
[4, 3, 2, 1]
[4, 3, 1, 2]
[4, 1, 3, 2]
[4, 1, 2, 3]
'''

# 위와 같은 재귀 형식을 구현하지 못하면 다음과 같은 4중 for문을 사용해야 한다

P = [1, 2, 3, 4]
arr = [0]*len(P)
# 각 항에 들어갈 수 있는 모든 수를 고려
for i1 in range(1, 5):
    for i2 in range(1, 5):
        if i2 != i1:    # 숫자 중복 방지
            for i3 in range(1, 5):
                if i3 != i1 and i3 != i2:   # 숫자 중복 방지
                    for i4 in range(1, 5):
                        if i4 != i3 and i4 != i2 and i4 != i1:  # 숫자 중복 방지
                            arr[0] = i1
                            arr[1] = i2
                            arr[2] = i3
                            arr[3] = i4
                            #print(arr)
'''
[1, 2, 3, 4]
[1, 2, 4, 3]
[1, 3, 2, 4]
[1, 3, 4, 2]
[1, 4, 2, 3]
[1, 4, 3, 2]
[2, 1, 3, 4]
[2, 1, 4, 3]
[2, 3, 1, 4]
[2, 3, 4, 1]
[2, 4, 1, 3]
[2, 4, 3, 1]
[3, 1, 2, 4]
[3, 1, 4, 2]
[3, 2, 1, 4]
[3, 2, 4, 1]
[3, 4, 1, 2]
[3, 4, 2, 1]
[4, 1, 2, 3]
[4, 1, 3, 2]
[4, 2, 1, 3]
[4, 2, 3, 1]
[4, 3, 1, 2]
[4, 3, 2, 1]
'''
```

---

## 연속한 1의 개수

```python
'''
N개의 0과 1로 이루어진 수열에서 연속한 1의 개수 중 최대값을 출력하는 프로그램을 만드시오.

입력
첫 줄에 테스트케이스 개수 T, 다음 줄부터 테스트케이스별로 첫 줄에 수열의 길이 N, 다음 줄에 N개의 0과1로 구성된 수열이 공백없이 제공된다.
1<=T<=10, 10<=N<=1000

출력
#과 테스트케이스 번호, 빈칸에 이어 답을 출력한다.

입력 예
3
10
0011001110
10
0000100001
10
0111001111

출력 예
#1 3
#2 1
#3 4
'''
# 1차원 배열을 묻는 문제다

# 1 정석
N = int(input())
arr = list(map(int, input()))
cnt = 0
maxV = 0
for i in range(N):
    if arr[i] == 1:
        cnt += 1
        if maxV < cnt:
            maxV = cnt
    else:
        cnt = 0
print(maxV)

# 2 식 세우기
'''
N = int(input())
arr = list(map(int,input()))
maxV = 0
for i in range(1, N):
    arr[i] = arr[i-1] * arr[i] + arr[i]
    maxV = max(arr)
print(maxV)
'''
```

---

## atoi 구현 (String)

```python
# int(str) 구현
def atoi(s):
    i = 0
    for char in s:
        i = i * 10 + ord(char) - ord('0') # 1 -> 10으로, 10 + 2 -> 12 -> 120으로, 120 + 3 -> 123
    return i

# str(int) 구현
# 나머지 연산자를 활용하여 뒤에서부터 잘라주기
def itoa(i):
    st = ''
    while i > 0:
        st = chr(i%10 + ord('0')) + st
        i //= 10
    return st

num = 123
word = '123'
atoi(word)
print(atoi(word)) # 123
print(type(atoi(word))) # <class 'int'>
print(itoa(num)) # 123
print(type(itoa(num))) # <class 'str'>
```

---