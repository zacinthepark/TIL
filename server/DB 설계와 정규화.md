## DB 설계와 ERD

---

### 1. DB설계의 목적

- 프로젝트, 명세서 등의 정보 요구사항에 대한 정확한 이해
- 분석자, 개발자, 사용자 간의 원활한 의사소통 수단
- 데이터 중심의 분석 방법
- 현행 시스템만이 아닌 신규 시스템 개발의 기초 제공

> 💡 설계를 대충하면 기능 한 개 추가될 때마다 DB와 관련된 이미 개발된 프로그램도 함께 뜯어고쳐야 하는 경우가 발생한다

### 2. 설계를 위한 요구사항 분석

데이터베이스에 대한 사용자의 요구사항을 수집하고 분석해서 아래와 같이 **요구사항(기능) 명세서**를 작성

![db1](https://github.com/zacinthepark/TIL/assets/86648892/c4322c39-4f98-49fe-aac0-ecda5dc0adcc)

### 3. 개념적 설계

작성한 요구사항 명세서에서 데이터베이스를 구성하는데 필요한 개체, 속성, 개체 간의 관계를 추출하여 **ERD**를 생성

1. 개체(Entity)와 속성(Attribute)을 추출한다
    -  대부분 명사로 선별한다

2. 개체 간의 관계(Relationship)을 추출한다
    -  대부분 동사로 선별한다 (개체간의 관계를 나타내는 동사이여야 한다)
    -  관계에 속한 속성도 있을 수 있다
    -  1:1, 1:N, N:M
    -  필수적인 참여, 선택적인 참여

### 3-1. 개체(Entity)와 속성(Attribute) 추출

요구사항에서 개체(Entity)는 대부분 명사로 이루어져 있지만, 속성(Attribute)과 구별하여 추출한다

![db2](https://github.com/zacinthepark/TIL/assets/86648892/f78514fe-489e-4c72-b918-8300cd3402c8)

### 3-2. 개체 간의 관계(Relationship) 추출

개체 간의 관계(Relationship)는 여러가지로 분류해서 정의된다

![db3](https://github.com/zacinthepark/TIL/assets/86648892/024c4aee-0178-4662-8603-cb9ee1318631)

### 3-3. 개념 설계 기반으로 ERD 생성

![db4](https://github.com/zacinthepark/TIL/assets/86648892/950fa4a3-6704-4e75-96e7-45269a1214fd)

### ✅ ERD 표준기호

![db5](https://github.com/zacinthepark/TIL/assets/86648892/cd598b45-f2bd-4635-a6d2-edf73fc7bc7f)

### 4. 논리적 설계

- 모든 개체는 릴레이션(Table)으로 변환
- N:M 관계는 릴레이션(Table)으로 변환
- 1:N 관계는 외래키로 표현
- 1:1 관계는 외래키로 표현
- 다중 값 속성은 독립 릴레이션(Table)으로 변환

### 4-1. 모든 개체는 릴레이션(Table)으로 변환

- ER 다이어그램의 각 개체를 릴레이션(Table)으로 변환
- 개체 → 테이블속성 → 테이블의 속성

![db6](https://github.com/zacinthepark/TIL/assets/86648892/a9a3b2e0-ee5d-4206-8b11-050dcd544210)

### 4-2. N:M 관계는 릴레이션(Table)으로 변환

관계 → 릴레이션 이름, 관계속성 → 릴레이션 속성

![db7](https://github.com/zacinthepark/TIL/assets/86648892/f18b553a-1363-4522-865f-872bd2038223)

### 4-3. 1:N 관계는 외래키(FK)로 표현

일반적으로  1:N 관계에서 1측 개체의 기본키를 N측 릴레이션에 포함시키고 외래키(FK)로 지정

![db8](https://github.com/zacinthepark/TIL/assets/86648892/117bef13-0869-4ba1-a053-e2a456a9c0ba)

### 4-4 1:1 관계는 외래키(FK)로 표현

일반적 1:1 관계는 외래키(FK)를 서로 주고받는다

![db9](https://github.com/zacinthepark/TIL/assets/86648892/a3c5db1e-9be4-42b7-bb69-bcd0026f1bd5)

### 4-5. 다중값 속성은 독립 릴레이션(Table)

릴레이션에서는 다중값 속성을 가질 수 없으므로 다중값 속성은 별도의 릴레이션으로 생성해야 함

![db10](https://github.com/zacinthepark/TIL/assets/86648892/581541cc-d8db-49d6-b795-84d70df20aaa)

### 5. 물리적 스키마 구현

ERD를 실제 테이블로 생성한다 (Workbench 같은 DB Tool이나 SQL스크립트 사용으로도 가능해야함)

![db11](https://github.com/zacinthepark/TIL/assets/86648892/0cb7d7a4-922c-4e59-bb92-bdd838333efa)

## 정규화와 반정규화

---

어떤 경우에 반정규화(역정규화)를 사용하는가?

### 1. DB 정규화(Normalization)

데이터 모델의 중복을 최소화하고 데이터의 일관성, 유연성을 확보하기 위한 목적으로 데이터를 분해하는 과정

![db12](https://github.com/zacinthepark/TIL/assets/86648892/1343d25d-fae0-41a0-bf43-e0cc00881b62)

통상적으로 제3정규화까지 진행

### 2. 반정규화(역정규화, De-Normalization)란?

- 정규화된 엔티티타입, 속성, 관계를 시스템의 성능향상, 개발과 운영의 단순화를 위해 모델을 통합하는 프로세스
- 정규화 모델: 이상적인 논리모델은 모든 엔티티타입, 속성, 관계가 반드시 한 개만 존재하며 따라서 입력, 수정, 삭제도 한군데에서만 발생하므로 데이터 값이 변질되거나 이질화될 가능성이 없다. 반면 여러 테이블이 생성되어야 하므로 **SQL 작성이 용이하지 않고 과다한 테이블 조인이 발생하여 성능이 저하될 가능성이 높다**
- 반정규화 모델: 반대로 반정규화를 하면 여러 개의 테이블이 단순해지므로 SQL 작성이 용이하고 성능이 향상될 가능성이 많다. 그러나 **같은 데이터가 여러 테이블에 걸쳐 존재하므로 무결성이 깨질 우려가 있다**
    - 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다

### 2-1. 반정규화를 사용하는 이유

- 읽는 시간을 최적화하도록 설계된 데이터베이스
- 정규화된 DB는 데이터 조회(select) 시에 조인(join)을 유발하기 때문에 CPU와 메모리를 많이 사용한다
- 반정규화는 다음과 같은 경우에 수행
    - 정규화에 충실하여 종속성, 활용성은 향상되었지만 수행속도가 느려진 경우
    - 다량의 범위를 자주 처리해야하는 경우
    - 특정 범위의 데이터만 자주 처리하는 경우
    - 요약, 집계 정보가 자주 요구되는 경우

### 3. 테이블 반정규화 방법

- 1:1 관계의 테이블 병합
- 1:N 관계의 테이블 병합
- 수퍼/서브 타입 테이블 병합
- 수직 분할 (집중화된 일부 컬럼을 분리)
- 수평 분할 (행으로 구분하여 구간별 분리)
- 테이블 추가 (중복테이블, 통계테이블, 이력케이블, 부분테이블)

### 4. 대표적 반정규화 - 컬럼 반정규화

- 중복 컬럼 추가 (자주 조회하는 컬럼이 있는 경우)
- 파생 컬럼 추가 (미리 계산한 값)
- PK에 의한 컬럼 추가
- 응용시스템 오작동을 위한 컬럼 추가 (이전데이터 임시 보관)

![db13](https://github.com/zacinthepark/TIL/assets/86648892/27f4879b-141a-4555-b591-bf06241f1828)

### 5. 대표적 반정규화 - 관계 반정규화

- 중복 관계 추가 (이미 A테이블에서 C테이블의 정보를 읽을 수 잇는 관계가 있음에도 관계를 중복하여 조회(Read) 경로를 단축)

![db14](https://github.com/zacinthepark/TIL/assets/86648892/1fe0e8a2-2435-47b1-b20b-671c64dbccf1)

### 6. 요약

반정규화? 정규화?

정답은 없다. 개념을 잘 알고 있어야 상황에 따라 적절하게 쓸 수 있다!
