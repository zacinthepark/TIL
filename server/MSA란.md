## Micro Service Architecture

---

### 등장배경: Monolithic Architecture

![monolithic1](https://github.com/zacinthepark/TIL/assets/86648892/5d9e2b28-3909-40bf-a30e-ded602206971)

- Monolithic Architecture란, 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어있는 형태
- 아직까지는 많은 소프트웨어가 Monolithic 형태로 구현되어있고, 소규모 프로젝트에는 Monolithic Architecture가 훨씬 합리적
- 간단한 Architecture이며, 유지보수가 용이
- 하지만 일정 규모 이상의 서비스에서 한계점 발생

    1. 서비스 및 프로젝트가 커지면 커질수록 영향도 파악 및 전체 시스템 구조 파악에 어려움이 있음

    2. 빌드 시간 및 테스트 시간, 그리고 배포 시간이 기하급수적으로 상승
        - 작은 수정에도 시스템 전체를 빌드해야 함
        - CI, CD가 강조되는 시점에서 큰 문제가 될 수 있음
            - Continuous Integration, Continuous Delivery?
            - 서비스 개발팀이 더 자주, 더 안정적으로 코드 변경을 제공하기 위해 사용하는 문화의 운영 원칙, 일련의 작업 방식
            - DevOps팀을 위한 권장 사항이자 Agile 방법론의 권장 사항이기도 함
            - CI: 다수의 개발자가 작성 및 수정한 소스코드를 지속적으로 통합 및 테스트하는 것
            - CD: 개발, 통합, 배포, 릴리즈, 테스트를 자동화하여 지속적으로 배포하는 것

    ![ci1](https://github.com/zacinthepark/TIL/assets/86648892/ceeccee2-17e4-432c-8693-25fab957466f)

    ![ci2](https://github.com/zacinthepark/TIL/assets/86648892/ce705f60-819d-4eda-a4a9-db40fff20136)

    3. 서비스를 부분적으로 scale-out하기 어려움

    4. 부분의 장애가 전체 서비스의 장애로 이어지는 경우 발생

### MSA란?

![msa](https://github.com/zacinthepark/TIL/assets/86648892/19bcb78e-381f-4d8e-91ab-4f8282afe529)

- 단일 프로그램을 각 컴포넌트 별로 나누어 작은 서비스 조합으로 구축하는 방법
- 각 컴포넌트는 서비스 형태로 구현되고 API를 이용하여 타 서비스와 통신하게 된다. 각 서비스는 독립된 서버로 타 컴포넌트와 의존성이 없기에 독립된 배포를 하게 된다. 또한 각 컴포넌트가 독립된 서비스로 개발되어있기 때문에 부분적인 확장이 가능하다. 온라인 쇼핑몰에서 주문 서비스에 트래픽이 증가한다면 해당 서버만 확장해주면 됨.

### 특징

### 1. 데이터 분리

데이터 저장 시 하나의 DB에 중앙 집중화를 하지 않고 서비스 별 별도의 DB를 사용한다. DB의 종류를 별도로 가져갈 수도 있고, 같은 DB를 사용하더라도 나누어 사용하게 된다. 데이터가 분산되어있기에 다른 서비스 컴포넌트에 대한 의존성 없이 서비스를 독립적으로 개발, 배포, 운영할 수 있지만 다른 컴포넌트의 데이터를 API 통신을 통해 가져와야 하기 때문에 성능상의 문제가 발생할 수 있고, transaction으로 묶을 수 없는 문제가 발생하기도 한다.

### 2. API Gateway

각 서비스가 다른 서버에 분리 배포되어있기에 서버 URL이 각기 다를 수 밖에 없다. 이 때 API Gateway는 API 서버 앞 단에서 모든 API 서버들의 End-Point를 단일화하여 묶어주는 역할을 한다. 또한 거미줄처럼 복잡한 API 서비스 간 API 호출 구조도 단순화 시켜준다.

### 3. 팀의 변화

![monolithic_team_model](https://github.com/zacinthepark/TIL/assets/86648892/72507941-31f1-429d-ab7c-b4a0e7388073)

![msa_team_model](https://github.com/zacinthepark/TIL/assets/86648892/6f810160-6c21-4b5c-b9ce-b57bc3508d79)

Monolithic Team Model

- 역할 별로 나누어진 팀 모델
- 인력 관리와 운영에 유연성을 부여하지만 팀 간 커뮤니케이션이 원활하지 않고 협업에 걸리는 시간이 지연되는 경우가 있음

MSA Team Model

- 서비스 별로 팀을 구분
- 서비스 기획, 설계, 개발, 운영이 팀 내에서 이루어지기에 다른 팀에 대한 의존성이 사라짐
- 역할 별 요청과 피드백이 빨라지고, 유연하고 지속적인 운영과 개발이 가능
- 인력 리소스 관리에 어려움이 생기기는 함
    - 각 팀의 역할 담당자들은 기본적인 업무 성숙도가 필요
    - 특히 개발자들은 운영팀 고유 영역이었던 인프라 핸들링이 가능해야함
    - AWS와 같은 클라우드 서비스 발달로 인해 직접적인 인프라 운영없이도 개발자가 운영 환경 설정 가능

### MSA 장점

배포(Deployment) 관점
- 서비스 별 개별 배포 가능
    - 배포 시 전체 서비스의 중단 없음
    - 요구사항을 신속하게 반영하여 빠르게 배포 가능

확장(Scaling) 관점
- 특정 서비스에 대한 확장성이 용이함
    - 클라우드 사용에 적합한 아키텍처

장애(Failure) 관점
- 장애가 전체 서비스로 확장될 가능성 적음
    - 부분적 장애에 대한 격리가 수월함

### MSA 단점

성능
- 서비스 간 호출 시 API를 사용하기 때문에 통신 비용이나, Latency가 그만큼 늘어남

테스트 and 트랜잭션
- 서비스가 분리되어 있기 때문에 테스트와 트랜잭션의 복잡도가 증가하고, 많은 자원을 필요로 함

데이터 관리
- 데이터가 여러 서비스에 걸쳐 분산되기 때문에 한 번에 조회하기 어렵고
- 데이터의 정합성 또한 관리하기 어려움

### 정리

- MSA는 복잡한 웹 시스템에 맞춰 개발된 API 기반의 서비스 지향적 아키텍처 스타일
- MSA가 유행을 하고 있지만 꼭 정답은 아니다
    - 업무나 비즈니스 특징에 따라 적절한 아키텍처 선택
- 아키텍처 모델은 시스템 설계, 팀의 구조, 프로젝트 관리 방법까지 좌우하기에 프로젝트에 미치는 영향이 크며, 때문에 거시적인 관점에서 고려해야함
- MSA가 필요하다 해도 꼭 시작을 MSA로 해야하는 것은 아님
    - MSA는 개개인의 숙련도가 필요한 편이기에 Monolithic 시스템으로 출발하여 팀원들의 숙련도를 높이고 피드백을 통해 MSA로 전환한 사례도 존재함
- MSA는 서비스 재사용성, 유연한 아키텍처 구조, 대용량 웹 서비스에 적합한 구조 등 많은 장점을 지님
