## WEB

---

### WWW(World Wide Web)

- 인터넷이란 전세계에 퍼져있는 거미줄같은 연결망
- 실제로 해저케이블로 전세계는 연결되어 있음
- Space X의 “스타링크 프로젝트"는 이러한 유선 연결을 넘어 무선 연결을 추구
- 인터넷을 이용한다는 것은 결국 전세계의 컴퓨터가 연결되어 있는 하나의 인프라를 이용하는 것

### 클라이언트와 서버

<img width="773" alt="dj_3" src="https://user-images.githubusercontent.com/86648892/188303737-89466c50-92bb-40ab-8c60-f802b075c2f9.png">

### 클라이언트

- 웹 사용자의 인터넷에 연결된 장치 (wi-fi에 연결된 컴퓨터 또는 모바일 등)
- Chrome 또는 Firefox와 같은 웹 브라우저
- **서비스를 요청하는 주체**

### 서버

- 웹 페이지, 사이트 또는 앱을 저장하는 컴퓨터
- 클라이언트가 웹 페이지에 접근하려고할 때
- 서버에서 클라이언트 컴퓨터로 웹 페이지 데이터를 응답해 사용자의 웹 브라우저에 표시됨
- **요청에 대해 서비스를 응답하는 주체**

### 클라이언트-서버

- Google 홈페이지에 접속한다는 것은?
    - 클라이언트에서 인터넷에 연결되어 있는 구글 컴퓨터에게
    - Google 홈페이지 html 달라고 요청
    - 구글 컴퓨터는 요청에 따라 인터넷을 통해 html 반환
    - 반환받은 html 파일을 브라우저가 렌더링하여 보여줌
- 결국 어떠한 자원(resource)을 요청(request)하는 것은 클라이언트, 자원을 제공하는 쪽은 서버(server)
- 웹은 클라이언트-서버 구조

### Web Browser

- 웹에서 **페이지를 찾아 보여주고**, **사용자가 하이퍼링크를 통해 다른 페이지로 이동**할 수 있도록 하는 프로그램
- 웹 페이지 파일을 우리가 보는 화면으로 렌더링(rendering)하는 프로그램

### Web Page

- 웹에 있는 문서로 우리가 보는 화면 하나하나가 웹 페이지
- Web Page 종류
    1. 정적 웹 페이지
    - Static Web Page
    - 있는 그대로를 제공하는 것(served as-is)
    - 한 번 작성된 html 파일의 내용이 변하지 않고 모든 사용자에게 동일한 모습으로 전달되는 것
    - 서버에 미리 저장된 HTML 파일 그대로 전달된 웹 페이지
    2. 동적 웹 페이지
    - Dynamic Web Page
    - 사용자와 요청에 따라 웹 페이지에 추가적인 수정이 되어 클라이언트에게 전달되는 웹 페이지
    - 웹 페이지의 내용을 바꿔주는 주체가 서버(server)
        - 서버에서 동작하고 있는 프로그램이 웹 페이지를 변경해줌
    - **사용자의 요청에 따라 적절한 응답을 만들어주는 프로그램**을 만들어야한다!
    - 파일을 처리하고, 데이터베이스와 상호작용

## HTTP

---

- HyperText Transfer Protocol
- HTML 문서와 같은 리소스(resource, 자원)들을 가져올 수 있도록 하는 프로토콜(규칙, 약속)
- 웹 상에서 컨텐츠를 전송하기 위한 약속
- 웹에서 이루어지는 모든 데이터 교환의 기초가 됨
- “클라이언트-서버 프로토콜”이라고도 부름
- 클라이언트와 서버는 다음과 같은 개별적인 메세지 교환에 의해 통신
    - 요청(request)
        - 클라이언트에 의해 전송되는 메세지
        - 행위를 정의
    - 응답(response)
        - 서버에서 응답으로 전송되는 메세지
        - 상태를 정의
- 실제로는 브라우저와 요청을 처리하는 서버 사이에는 더 많은 기술 및 컴퓨터들이 존재
    - 현재는 HTTP의 기본 명세에 대해 집중

## HTTP 특징

---

1. **비연결지향(connectionless)**

    - 연결되어있는 상태가 아니라 요청이 있을 때만 응답을 주고 끝
    - 서버는 요청에 대한 응답을 보낸 후 연결을 끊음
        - ex) 우리가 네이버 메인 페이지를 보고 있을 때 우리는 네이버 서버와 연결되어 있는 것이 아님
        - 네이버 서버는 우리에게 메인 페이지를 응답하고 연결을 끊은 것

2. **무상태(stateless)**

    - 비연결지향에 의해 상태 정보가 유지되지 않음
    - 연결을 끊는 순간 클라이언트와 서버 간의 통신이 끝나며 상태 정보가 유지되지 않음
    - 클라이언트와 서버가 주고받는 메세지들은 서로 완전히 독립적

### Stateless (무상태)

- 동일한 연결(connection)에서 연속적으로 수행되는 두 요청 사이에 링크가 없음
    - 즉, 응답을 마치고 연결을 끊는 순간 클라이언트와 서버 간 통신이 끝나며
    - 상태 정보가 유지되지 않음
- 이는 특정 페이지와 일관되게 상호작용하려는 사용자에게 문제가 될 수 있으며
    - 이를 해결하기 위해
    - 쿠키와 세션을 사용해
    - 서버 상태를 요청과 연결함

### 쿠키(Cookie)

- HTTP 쿠키는 “상태가 있는 세션”을 만들도록 해줌
- 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다
    - 쉽게 말해 브라우저에서 했던 행동을 저장해놓을 수 있는 곳
    - KEY-VALUE 형태로 저장
- 사용자가 웹사이트를 방문할 경우 해당 웹사이트의 서버를 통해 사용자의 컴퓨터에 설치되는 작은 기록 정보 파일
    1. 브라우저(클라이언트)는 쿠키를 로컬에 KEY-VALUE의 데이터 형식으로 저장
    2. 이렇게 쿠키를 저장해 놓았다가, **동일한 서버에 재요청 시 저장된 쿠키를 함께 전송**
- 쿠키는 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 주로 사용됨
    - 이를 이용해 사용자의 로그인 상태를 유지할 수 있음
    - 쿠키에 “나 로그인된 사용자야"라는 정보를 담아 매 요청마다 서버에 전송하는 것
    - 상태가 없는(stateless) HTTP 프로토콜에서 상태 정보를 기억시켜주기 때문
- 즉, 웹 페이지에 접속하면 웹 페이지를 응답한 서버로부터 쿠키를 받아 브라우저에 저장하고, 클라이언트가 같은 서버에 재요청 시마다 요청과 함께 저장해둔 쿠키도 함께 전송

<img width="1176" alt="dj_85" src="https://user-images.githubusercontent.com/86648892/189502186-1f8fd6e9-96f0-409a-b32c-1e969f5c9022.png">

### 쿠키 사용 목적

1. 세션 관리(Session Management)
    - 로그인, 아이디 자동완성, 공지 하루 안보기, 팝업 체크, 장바구니 등의 정보 관리
2. 개인화(Personalization)
    - 사용자 선호, 테마 등의 설정
3. 트래킹(Tracking)
    - 사용자 행동을 기록 및 분석
    - 어떤 상품을 많이 봤는지 등

### 쿠키 확인

- 개발자도구 - Network 탭

<img width="647" alt="dj_86" src="https://user-images.githubusercontent.com/86648892/189502187-073710a1-dd7b-474a-96a3-c3214d9a2f02.png">

- 서버는 Set-Cookie 응답 헤더를 브라우저에게 전송
- 이 헤더를 통해 클라이언트에게 쿠키를 저장하라고 전달

<img width="697" alt="dj_87" src="https://user-images.githubusercontent.com/86648892/189502189-634de91f-41be-4202-b8f9-149678e5e125.png">

- 브라우저 역시 서버로 전송되는 모든 요청에 Cookie HTTP 헤더를 사용해 서버로 이전에 저장했던 모든 쿠키들을 함께 전송
- 위 예시는 쿠팡 장바구니 정보를 저장
- 개발자도구 - Application 탭 - Cookies
- 저장되어 있는 쿠키 확인

<img width="755" alt="dj_88" src="https://user-images.githubusercontent.com/86648892/189502190-f6e16994-6d70-4ddd-ab06-192f4982cf6b.png">

- 쿠키를 지우면(우측 클릭 - Clear) 상태가 유지되지 않는 것을 확인할 수 있음

### 세션(Session)

- 사이트와 특정 브라우저 사이의 “state(상태)”를 유지시키는 것
- 클라이언트가 서버에 접속하면
- 서버가 특정 session id를 발급하고, 클라이언트는 session id를 쿠키에 저장
- 클라이언트가 다시 동일한 서버에 접속하면 요청과 함께 쿠키(session id가 저장된)를 서버에 전달
    - 쿠키는 요청 때마다 서버에 함께 전송되므로 서버에서 session id를 확인해 알맞은 로직을 처리
- session id는 세션을 구별하기위해 필요하며, 쿠키에는 session id만 저장

### 쿠키 Lifetime(수명)

1. **Session cookie**

- 현재 세션(current session)이 종료되면 삭제됨
- 브라우저 종료와 함께 세션이 삭제됨

2. **Persistent cookies**

- Expires 속성에 지정된 날짜 혹은 Max-Age 속성에 지정된 기간이 지나면 삭제됨

### HTTP Request Methods

- 리소스에 대한 행위(수행하고자 하는 동작)를 정의
- 즉, 리소스에 대해 수행할 원하는 작업을 나타내는 메서드 모음을 정의
- HTTP verbs라고도 칭함
- HTTP Request Methods
    1. **GET (R)**
        - 서버에 리소스의 표현을 요청
        - GET을 사용하는 요청은 데이터만 검색해야함
    2. **POST (C)**
        - 데이터를 지정된 리소스에 제출(submit)
        - 서버의 상태를 변경
    3. **PUT (U)**
        - 요청한 주소의 리소스를 수정
    4. **DELETE (D)**
        - 지정된 리소스를 삭제

### [참고] 리소스 (resource)

- **리소스(resource)**
- HTTP 요청의 대상을 리소스(resource, 자원)라고 함

### HTTP response status codes

- 특정 HTTP 요청이 성공적으로 완료되었는지 여부를 나타냄
- 응답은 5개의 그룹으로 구분
    1. Informational responses (100-199)
    2. Successful responses (200-299)
    3. Redirection messages (300-399)
    4. Client error responses (400-499)
    5. Server error response (500-599)

## 웹에서의 리소스 식별

---

- HTTP 요청의 대상을 리소스(resource)라고 함
    - 리소스는 문서, 사진 또는 기타 어떤 것이든 될 수 있음
    - 각 리소스는 식별을 위해 **URI**로 식별됨

- 자원의 식별자 (URI)
    - 자원의 **위치**로 자원을 식별 (URL)
    - 고유한 **이름**으로 자원을 식별 (URN)

### URI

- Uniform Resource Identifier: 통합 자원 식별자
- 인터넷에서 하나의 리소스를 가리키는 문자열
- **URL**: 가장 일반적인 URL는 웹 주소로 알려진 URL

![dj_239](https://user-images.githubusercontent.com/86648892/212551498-8af5bd3b-3dfb-41ef-9974-bd813e368851.png)

- **URN**: 특정 이름공간에서 이름으로 리소스를 식별하는 URI는 URN

![dj_240](https://user-images.githubusercontent.com/86648892/212551497-404f8f1b-7c57-4a42-b785-bd06a0b3e02d.png)

### URL

- Uniform Resource Locator: 통합 자원 위치
- 웹에서 주어진 리소스의 주소
- 네트워크 상에 리소스가 어디 있는지(주소)를 알려주기 위한 약속
- 이러한 리소스는 HTML, CSS, 이미지 등이 될 수 있음

![dj_241](https://user-images.githubusercontent.com/86648892/212551494-ac1d0105-dabe-40cc-9581-f78b47367b2b.png)

### URL 구조

- **Scheme (or protocol)**
    - 브라우저가 리소스를 요청하는데 사용해야 하는 프로토콜
    - URL의 첫 부분은 브라우저가 어떤 규약을 사용하는지를 나타냄
    - 기본적으로 웹은 HTTP(S)를 요구하며 메일을 열기 위한 `mailto:`, 파일을 전송하기 위한 `ftp:` 등 다른 프로토콜도 존재
    ![dj_242](https://user-images.githubusercontent.com/86648892/212551493-cdf340f3-792b-454f-9e9a-ea7816674425.png)

- **Authority**
    - Scheme 다음으로 문자 패턴 `://` 으로 구분된 Authority(권한)이 작성됨
    - Authority는 domain과 port를 모두 포함하며 둘은 `:` (colon)으로 구분됨
    ![dj_243](https://user-images.githubusercontent.com/86648892/212551492-66fde450-cb27-4bed-ab37-50662b72c61d.png)
    - **Domain Name**
        - `www.example.com`
        - 요청 중인 웹 서버를 나타냄
        - 어떤 웹 서버가 요구되는지를 가리키며 직접 IP 주소를 사용하는 것도 가능
            - ex) 도메인 google.com의 IP 주소는 142.251.42.142

  - **Port**
    - `80`
    - 웹 서버의 리소스에 접근하는데 사용되는 기술적인 문 (Gate)
    - HTTP 프로토콜의 표준 포트는 다음과 같고 생략 가능 (나머지는 생략 불가)
        - HTTP
            - 80
        - HTTPS
            - 443
    - Django의 경우 8000(80+00)이 기본 포트로 설정되어 있음

- **Path**
    - 웹 서버의 리소스 경로
    - 초기에는 실제 파일이 위치한 물리적 위치를 나타냈지만
    - 오늘날은 실제 위치가 아닌 추상화된 형태의 구조를 표현 - ex) `/articles/create/` 가 실제 articles 폴더 안의 create 폴더 안을 나타내는 것은 아님
        ![dj_244](https://user-images.githubusercontent.com/86648892/212551491-cd332a29-034e-4be4-9898-70061fab280d.png)

- **Parameters**
    - 웹 서버에 제공하는 추가적인 데이터
    - `&` 기호로 구분되는 key-value 쌍 목록
    - 서버는 리소스를 응답하기 전에 이러한 파라미터를 사용하여 추가 작업을 수행할 수 있음
    ![dj_245](https://user-images.githubusercontent.com/86648892/212551490-af5a135c-d465-4450-95ae-ee3e78d3bae9.png)

- **Anchor**
    - 리소스의 다른 부분에 대한 앵커
        - 하이퍼링크와 비슷한 기능을 하는 인터넷 상의 다른 문서와 연결된 문자 혹은 그림
    - 리소스 내부 일종의 “북마크”를 나타내며 브라우저의 해당 북마크 지점에 있는 컨텐츠를 표시
        - ex) HTML 문서에서 브라우저는 앵커가 정의한 지점으로 스크롤함
    - fragment identifier(부분 식별자)라 부르는 `#` 이후 부분은 서버에 전송되지 않음
        - ex) `https://docs.djangoproject.com/en/3.2/intro/install/#quick-install-guide` 요청에서 `#quick-install-guide` 는 서버에 전달되지 않고 브라우저에게 해당 지점으로 이동할 수 있도록 함
        ![dj_246](https://user-images.githubusercontent.com/86648892/212551487-804cc47a-8b3b-4fac-b89d-41b19b376be1.png)

### [참고] URN

- Uniform Resource Name: 통합 자원 이름
- URL과 달리 자원의 위치에 영항을 받지 않는 유일한 이름 역할을 함 (독립적 이름)
- URL의 단점을 극복하기 위해 등장
    - 자원이 어디에 위치한지 여부와 관계없이 이름만으로 자원을 식별
- 그러나 이름만으로 실제 리소스를 찾는 방법은 보편화되어있지 않아 현재는 URL을 대부분 사용
- 예시
    - ISBN
        - 국제표준 도서번호
        - 국제적으로 책에 붙이는 고유 식별자
    - ISAN
        - 국제표준 시청각 자료번호
        - 도서의 ISBN과 유사항 시청각 작품 및 관련 버전의 고유 식별자

## REST API

---

### API

- Application Programming Interface
- 어플리케이션과 프로그래밍으로 소통하는 방법
    - 개발자가 복잡한 기능을 보다 쉽게 만들 수 있도록 프로그래밍 언어로 제공되는 구성
- API를 제공하는 어플리케이션과 다른 소프트웨어 및 하드웨어 등의 것들 사이의 간단한 계약(인터페이스)이라고 볼 수 있음
- API는 복잡한 코드를 추상화하여 대신 사용할 수 있는 더 쉬운 구문을 제공
    - 일상생활에 비유하자면 우리는 가전 제품의 플러그를 소켓에 꽂기만 하면 되고
    - 우리는 가전 제품에 전기를 공금하기 위해 직접 배선을 하지 않는다!

### Web API

- 웹 서버 또는 웹 브라우저를 위한 API
- 현재 웹 개발은 모든 것을 하나부터 열까지 직접 개발하기보다 여러 Open API를 활용하는 추세
    - Open API?
        - 개발자라면 누구나 사용할 수 있도록 공개된 API
        - 개발자에게 사유 응용 소프트웨어나 웹 서비스의 프로그래밍적 권한을 제공
- 대표적인 Third Party Open API 서비스 목록
    - Youtube API
    - Naver Papago API
    - Kakao Map API
- API는 다양한 타입의 데이터를 응답
    - HTML
    - XML
    - JSON
    - etc
    - 현대 API는 대부분 JSON 타입의 데이터를 응답

### REST

- **Representational State Transfer**
- API Server를 개발하기 위한 일종의 소프트웨어 설계 방법론
    - 2000년 로이 필딩의 박사학위 논문에서 처음으로 소개된 후 네트워킹 문화에 널리 퍼짐
- “A group of software architecture design constraints”
    - 소프트웨어 아키텍쳐 디자인 제약 모음
- REST 원리는 따르는 시스템을 **RESTful**하다고 부름

- REST의 기본적은 근간은 리소스(자원)
    - 자원을 정의하고 자원에 대한 주소를 지정하는 전반적인 방법을 서술
    - **자원을 어떻게 할 것인가**
    - **자원을 어떻게 정의할 것**인가
        - 어떤 식으로 설계하고 표현할 것인가
    - **주소를 어떤 식으로 지정할 것**인가

### REST에서 자원을 정의하고 주소를 지정하는 방법

1. 자원의 **식별**
    - **URI**
    - URI로 자원을 식별한다
2. 자원의 **행위**
    - **HTTP Method**
    - GET, POST, PUT, DELETE
    - 이 메소드들로 자원의 행위를 결정한다
3. 자원의 **표현**
    - 자원과 행위를 통해 궁극적으로 표현되는 (추상화된) **결과물**
    - JSON으로 표현된 데이터를 제공
    - JSON으로 자원을 표현한다

**즉, RESTful API란 자원을 URI로 식별하고, 자원의 행동을 HTTP Method로 결정하고, 해당 자원의 최종적인 표현을 JSON으로 표현하자는 방법론을 약속으로 지키는 API를 의미**

### JSON

- JSON is a lightweight data-interchange format
- JavaScript의 표기법을 따른 **단순 문자열**
- 파이썬의 dictionary, 자바스크립트의 object처럼
    - C 계열의 언어가 갖고 있는 자료구조로 쉽게 변환할 수 있는
    - **key-value 형태의 구조**를 갖고 있음
- 사람이 읽고 쓰기 쉽고
    - 기계가 파싱(해석&분석)하고 만들어내기 쉽기 때문에
    - 현재 API에서 가장 많이 사용하는 데이터 타입
- JSON 파일 예시
<img width="479" alt="dj_247" src="https://user-images.githubusercontent.com/86648892/212551486-da92c751-1257-4fe5-afdf-a823bd2044c7.png">

### REST 정리

- “자원을 정의하고 자원에 대한 주소를 지정하는 방법의 모음”

1. 자원의 식별
    - URL
2. 자원에 대한 행위
    - HTTP Methods
3. 자원을 표현
    - JSON

- 설계 방법론은 지키지 않았을 때 잃는 것보다 지켰을 때 얻는 것이 훨씬 많음
    - 단, 설계 방법론을 지키지 않더라도 동작 여부에 큰 영향을 미치지는 않음
    - 말 그대로 방법론일 뿐이며 규칙이나 규약은 아님
- **RESTful한 서버를 만든다는 것은 결국 해당 데이터베이스에 대한 클라이언트의 요청과 관련하여**
    - **JSON으로 응답을 반환하고**
    - **해당 요청 자원은 URL로 식별 가능하며**
    - **그 과정에 있어서 HTTP Methods를 사용하는 서버를 뜻한다고 이해하자**
- RESTful API는 결국
    1. **행위는 method로**
    2. **자원은 path로**
    3. 다룬다는 2가지 규칙을 지키는 것을 의미한다
